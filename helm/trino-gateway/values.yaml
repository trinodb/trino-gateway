replicaCount: 1

image:
    repository: "trinodb/trino-gateway"
    pullPolicy: IfNotPresent
    # Override the image tag whose default is the chart appVersion.
    #tag: "10-SNAPSHOT"

    # For local testing
    #repository: "trino-gateway"
    #pullPolicy: IfNotPresent
    #tag: "8-SNAPSHOT"

initContainer:
    repository: "trinodb/trino-gateway-init"
    pullPolicy: IfNotPresent
    tag: "13-SNAPSHOT"
    command:
      - "python"
      - "/tmp/interpolate_env_vars.py"
      - "/etc/gateway/raw-config.yaml"
      - "/etc/gateway/config.yaml"

imagePullSecrets: []

# Provide a list of secrets and configmaps to mount into the init container as environment variables.
# These environment variables may be interpolated into the configuration file by using
# ${ENV:VAR_NAME} in place of a raw value. Example:
#  kubectl create secret generic test-secret --from-literal=USER='me' --from-literal=PASSWORD='39528$vdg7Jb'
#
#envFrom:
#  - secretRef:
#      name: test-secret
#
#  dataStore:
#    jdbcUrl: jdbc:postgresql://localhost:5432/gateway
#    user: ${ENV:USER}
#    password: ${ENV:PASSWORD}
#    driver: org.postgresql.Driver
envFrom: []

# Provide configuration for the Trino Gateway dataStore, backendState and authentication as
# secrets. These secrets should contain the entire yaml snippet, starting with the root node.
# For example, if you have a file containing the following snippet in a file named my-data-store.yaml,
# you should
# kubectl create secret generic data-store-secret --from-file my-data-store.yaml
# and set:
#dataStoreSecret:
#    name: "data-store-secret"
#    key: "my-data-store.yaml"
#
# File contents:
#dataStore:
#  jdbcUrl: jdbc:postgresql://localhost:5432/gateway
#  user: postgres
#  password: mysecretpassword
#  driver: org.postgresql.Driver
#
# Secrets are appended to the configuration defined in the config.yaml node. If multiple secrets are
# used, make sure each ends in a newline!
dataStoreSecret:
    name: ""
    key: ""

backendStateSecret:
    name: ""
    key: ""

authenticationSecret:
    name: ""
    key: ""

config:
    serverConfig:
        node.environment: test
        http-server.http.port: 8080
    dataStore:
        # The connection details for the backend database for Trino Gateway and Trino query history
        jdbcUrl: jdbc:postgresql://localhost:5432/gateway
        user: postgres
        password: mysecretpassword
        driver: org.postgresql.Driver
    clusterStatsConfiguration:
        monitorType: INFO_API
    modules:
        - io.trino.gateway.ha.module.HaGatewayProviderModule
        - io.trino.gateway.ha.module.ClusterStateListenerModule
        - io.trino.gateway.ha.module.ClusterStatsMonitorModule
    managedApps:
        - io.trino.gateway.ha.clustermonitor.ActiveClusterMonitor

# Startup command for Trino Gateway process. Add additional Java options and other modifications as desired.
command:
  - "java"
  - "-XX:MinRAMPercentage=80.0"
  - "-XX:MaxRAMPercentage=80.0"
  - "-jar"
  - "/usr/lib/trino/gateway-ha-jar-with-dependencies.jar"
  - "/etc/gateway/config.yaml"

service:
  type: ClusterIP
  port: 8080

ingress:
  enabled: false
  className: ""
  annotations: {}
    # kubernetes.io/ingress.class: nginx
    # kubernetes.io/tls-acme: "true"
  hosts:
    - host: chart-example.local
      paths:
        - path: /
          pathType: ImplementationSpecific
  tls: []
  #  - secretName: chart-example-tls
  #    hosts:
  #      - chart-example.local

resources:
 limits:
   cpu: 2
   memory: 4Gi
 requests:
   cpu: 2
   memory: 4Gi

autoscaling:
  enabled: false
  minReplicas: 1
  maxReplicas: 100
  targetCPUUtilizationPercentage: 80
  # targetMemoryUtilizationPercentage: 80

livenessProbe:
  initialDelaySeconds: 30
  periodSeconds: 10
  failureThreshold: 3
  timeoutSeconds: 1
  scheme: HTTP

readinessProbe:
  initialDelaySeconds: 5
  periodSeconds: 5
  failureThreshold: 12
  timeoutSeconds: 1
  scheme: HTTP

volumes: {}

volumeMounts: {}

nodeSelector: {}

tolerations: []

affinity: {}

# -- Labels that get applied to every resource's metadata
commonLabels: {}
  # example: "some label"

podAnnotations: {}

podLabels: {}

podSecurityContext: {}
# fsGroup: 2000

securityContext: {}
  # capabilities:
  #   drop:
  #   - ALL
  # readOnlyRootFilesystem: true
  # runAsNonRoot: true
# runAsUser: 1000

serviceAccount:
    # Specifies whether a service account should be created
    create: true
    # Automatically mount a ServiceAccount's API credentials?
    automount: true
    # Annotations to add to the service account
    annotations: {}
    # The name of the service account to use.
    # If not set and create is true, a name is generated using the fullname template
    name: ""

{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":"<p>Trino Gateway is a load balancer, proxy server, and configurable routing  gateway for multiple Trino clusters.</p>"},{"location":"#use-cases-advantages-and-features","title":"Use cases, advantages, and features","text":"<ul> <li>Use of a single connections URL for client tool users with workload   distribution across multiple Trino clusters.</li> <li>Automatic routing of queries to dedicated Trino clusters for specific   workloads or specific queries and data sources.</li> <li>No-downtime upgrades for Trino clusters behind the Trino Gateway in a   blue/green model or canary deployment model.</li> <li>Transparent change of capacity of Trino clusters without user interruptions.</li> </ul>"},{"location":"#high-level-architecture","title":"High-level architecture","text":"<p>Find more information in our resources page, the users page, and the rest  of the documentation.</p>"},{"location":"design/","title":"Design","text":"<p>There are two types of requests: one is a request to Trino Gateway, and the other is a request that needs to be forwarded to Trino.</p>"},{"location":"design/#request-forwarding","title":"Request forwarding","text":"<p>Trino Gateway forwards some pre-defined URIs automatically to Trino. You can configure additional URIs to forward with the <code>extraWhitelistPaths</code> configuration.</p> <p>In order to support additional URIs that are only known at runtime, the <code>RouterPreMatchContainerRequestFilter</code> is used to process every request before the actual resource matching occurs. If the requests URI matches, the request is forwarded to <code>RouteToBackendResource</code>.</p> <p>Flow of request forwarding:</p> <ol> <li>Determine to which Trino cluster a query should be routed to.</li> <li>Prepare a request to send to Trino by adding <code>Via</code> headers and <code>X-Forwarded</code>    headers. Most headers are forwarded to Trino unmodified.</li> <li>Some request URI require special handling. For example, a    request which submit a new query, Trino Gateway retrieves the queryId from the    response from Trino. Some requests to the web UI require setting a session    cookie to ensure OIDC works. These are done by chaining asynchronous    operations using <code>Future</code>.</li> <li>The execution of requests to Trino and the response to the client are handled    by <code>airlift.jaxrs.AsyncResponseHandler</code>.</li> </ol>"},{"location":"development/","title":"Development","text":""},{"location":"development/#build-requirements","title":"Build requirements","text":"<ul> <li>Mac OS X or Linux</li> <li>Java 25+, 64-bit</li> <li>Docker</li> </ul>"},{"location":"development/#running-trino-gateway-in-your-ide","title":"Running Trino Gateway in your IDE","text":"<p>The best way to run Trino Gateway for development is to run the <code>TrinoGatewayRunner</code> class. You need to run <code>io.trino.gateway.TrinoGatewayRunner.main()</code> method on your IDE or execute the following command:</p> <pre><code>./mvnw test-compile exec:java -pl gateway-ha -Dexec.classpathScope=test -Dexec.mainClass=\"io.trino.gateway.TrinoGatewayRunner\"\n</code></pre>"},{"location":"development/#build-and-run","title":"Build and run","text":""},{"location":"development/#locally","title":"Locally","text":"<p>This project requires Java 25. Note that higher version of Java have not been verified and may run into unexpected issues.</p> <p>Run <code>./mvnw clean install</code> to build <code>trino-gateway</code>. VM options required for compilation and testing are specified in <code>.mvn/jvm.config</code>.</p> <p>Edit the configuration file <code>config.yaml</code> in the <code>gateway-ha</code> folder and update the mysql db information.</p> <p>Note that tests using Oracle are disabled by default on non-x86_64 CPU architectures. To enable them, set the environment variable <code>TG_RUN_ORACLE_TESTS=true</code>. These tests will always be run in GitHub CI.</p> <pre><code>cd gateway-ha/target/\njava -jar gateway-ha-{{VERSION}}-jar-with-dependencies.jar ../config.yaml\n</code></pre>"},{"location":"development/#in-docker","title":"In Docker","text":"<p>Follow the separate instructions for building the container and running Trino Gateway with docker compose from the <code>README.md</code> file in the <code>docker</code> folder.</p>"},{"location":"development/#contact-help-and-issues","title":"Contact, help, and issues","text":"<p>You can contact the Trino Gateway users and contributors on Trino slack in the <code>#trino-gateway</code> and <code>#trino-gateway-dev</code> channels. Use these channels for questions and discussion about Trino Gateway installation, usage, and development.</p> <p>If you encounter specific issues or want to propose new features, file an issue and follow the contribution process for next steps.</p>"},{"location":"development/#contributing","title":"Contributing","text":"<p>Want to help build Trino Gateway? Check out our contributing documentation</p>"},{"location":"development/#maintainers","title":"Maintainers","text":"<p>The following Trino and Trino Gateway maintainers are involved in Trino Gateway, and can help with pull request reviews and merges.</p> <ul> <li> chaho12 - Jaeho Yoo</li> <li> ebyhr - Yuya Ebihara</li> <li> mosabua - Manfred Moser</li> <li> oneonestar - Star Poon</li> <li> vishalya - Vishal Jadhav</li> <li> wendigo - Mateusz Gajewski</li> </ul>"},{"location":"development/#contributor-meetings","title":"Contributor meetings","text":"<p>Contributor meetings are open to anyone and held every two weeks. Meeting notes and other details are available on GitHub.</p>"},{"location":"development/#release-process","title":"Release process","text":"<p>A full release process consists a number of steps.</p> <ol> <li> <p>Create a release notes pull request including the following changes:</p> <ul> <li>Add new release notes in <code>docs/release-notes.md</code>.</li> <li>Update <code>VERSION</code> in <code>docs/quickstart.md</code>. </li> </ul> <p>See the example pull request for Trino Gateway   17 for more details.</p> </li> <li> <p>In parallel prepare a pull request to update the Trino Gateway Helm chart in    the charts repository:</p> <ul> <li>Update <code>appVersion</code> to new version and <code>version</code> to the new version   <code>1.x.0</code>, where <code>x</code> is the Trino Gateway version <code>charts/gateway/Chart.yaml</code>. For example, update to <code>appVersion: \"17\"</code> and <code>version: \"1.17.0\"</code>.</li> <li>Update the links <code>charts/gateway/README.md</code></li> <li>Update the version table in <code>README.md</code></li> </ul> <p>See the example pull request for the 1.17.0 chart for more details.</p> </li> <li> <p>Organize review and approval for the release notes PR.</p> </li> <li> <p>Confirm that the team wants to proceed with a release via discussions in the    developer syncs and the slack channel.</p> </li> <li> <p>Confirm that the main branch builds are successful.</p> </li> <li> <p>Merge the release notes pull request.</p> </li> <li> <p>After the release notes PR is merged, kick off the release    workflow    to deploy the binaries to Maven Central. A successful release build performs    the necessary commits, and pushes the binaries to Maven Central.</p> </li> <li> <p>Wait until the workflow completes and until the binaries available on Maven    Central. A    folder with the new version should be visible and the link in the release to    the JAR must work.</p> </li> <li> <p>Once the binaries are on Maven Central you can kick off the release workflow    for publishing the container image to Docker    Hub.</p> </li> <li> <p>With the deployment completed, you can verify the container by pulling it     down manually, for example with:</p> <pre><code>docker pull trinodb/trino-gateway:17\n</code></pre> <p>You can also verify availability at https://hub.docker.com/r/trinodb/trino-gateway.</p> </li> <li> <p>Push to the pull request in the charts repository and confirm that the build     is now successful, since it can finally pull the referenced container image.</p> </li> <li> <p>Once the PR in the charts repository completed, request review and approval     and merge the PR to publish the Helm chart.</p> </li> <li> <p>Announce the release on Trino Slack and LinkedIn.</p> </li> <li> <p>Go back to reviewing PRs, writing code, and get ready for another release     preparation.</p> </li> </ol>"},{"location":"docker/","title":"Trino Gateway Docker image","text":"<p>The Docker image of Trino Gateway is designed for the following use cases:</p> <ul> <li>Manual usage in front of Trino clusters with <code>docker</code> or <code>docker-compose</code>    commands for development and testing.</li> <li>Automated usage with Helm chart for deployment of the container on   Kubernetes.</li> </ul> <p>The latest version of the Trino Gateway container image is available on  DockerHub with the identifier <code>trinodb/trino-gateway</code>. Append  where  <code>:&lt;version&gt;</code> with a version number to use a specific release, for example  <code>trinodb/trino-gateway:11</code>.</p>"},{"location":"docker/#production-setup","title":"Production setup","text":"<p>The healthcheck configurations in the <code>docker-compose</code> file is for suitable  for development and testing purposes only. Change the configuration for  your production deployment based on the workload and your specific requirements.</p>"},{"location":"docker/#build-requirements","title":"Build requirements","text":"<p>This docker build process requires the following software:</p> <ul> <li>Docker Compose V2</li> <li>jq</li> </ul>"},{"location":"docker/#building-a-custom-docker-image","title":"Building a custom Docker image","text":"<p>Use the following steps to build a Docker image from your local Trino Gateway codebase</p> <p>First, run the Maven build in the project root.</p> <p>Then build the image for your desired processor architecture in the <code>docker</code> directory:</p> <pre><code>./build.sh -a arm64\n</code></pre> <p>By default, the scripts builds all valid processor architectures <code>amd64</code>, <code>arm64</code>, and <code>ppc64le</code>:</p> <pre><code>./build.sh\n</code></pre> <p>The Docker build process prints the ID of the built image. It also tags the image with <code>trino-gateway:xxx-SNAPSHOT-yyy</code>, where <code>xxx-SNAPSHOT</code> is the version number and<code>-yyy</code> is the processor architecture:</p> <pre><code>$ docker images\nREPOSITORY            TAG                  IMAGE ID       CREATED          SIZE\ntrino-gateway         6-SNAPSHOT-ppc64le   a72b750d2745   33 seconds ago   547MB\ntrino-gateway         6-SNAPSHOT-arm64     bc5e8b0db63c   35 seconds ago   523MB\ntrino-gateway         6-SNAPSHOT-amd64     6c066fa5b0c5   36 seconds ago   518MB\n...\n</code></pre> <p>To build an image for a specific, already released version of Trino Gateway, use the <code>-r</code> option. The build script downloads all the required artifacts:</p> <pre><code>./build.sh -r 4\n</code></pre> <p>Set the environment variable <code>TRINO_GATEWAY_BASE_IMAGE</code> to use a specific base image to build Trino Gateway image.</p> <pre><code>export TRINO_GATEWAY_BASE_IMAGE=&lt;image&gt;\n./build.sh\n</code></pre> <p>Use the <code>-h</code> option for further help.</p>"},{"location":"docker/#run-trino-gateway","title":"Run Trino Gateway","text":"<p>You can launch Trino Gateway and required PostgreSQL for testing purposes with the following command examples using <code>docker compose</code>.</p> <p>Use a locally-built image on a ARM-based machine, such as a Macbook laptop.</p> <pre><code>export TRINO_GATEWAY_IMAGE=\"trino-gateway:6-SNAPSHOT-arm64\"\n</code></pre> <p>Use a locally-built image on a AMD64-based machine, such as a typical Windows or Linux desktop or laptop.</p> <pre><code>export TRINO_GATEWAY_IMAGE=\"trino-gateway:6-SNAPSHOT-amd64\"\n</code></pre> <p>Use a published image from Docker Hub.</p> <pre><code>export TRINO_GATEWAY_IMAGE=\"trinodb/trino-gateway:latest\"\n</code></pre> <p>The release process publishes images for Trino Gateway 6 and newer to DockerHub.</p> <p>Next set the image and platform:</p> <p>Start Trino Gateway and its PostgreSQL backend database, and wait until the  health check is successful:</p> <pre><code>docker compose up --wait\n</code></pre> <p>Inspect the logs for progress and troubleshooting:</p> <pre><code>docker compose logs trino-gateway\n</code></pre> <p>Typically your operating system automatically sets the default Docker platform value. In some cases it can be useful to explicitly set it.</p> <p>For example, on ARM64-based MacOS you can set it to use <code>linux</code> because it  otherwise is potentially set to <code>darwin</code> and there are no PostgreSQL images  available for <code>darwin</code> and this can prevent starting the Trino Gateway with docker compose.</p> <pre><code>export DOCKER_DEFAULT_PLATFORM=\"linux/arm64\"\n</code></pre> <p>You can also set platform without operating system identifier:</p> <pre><code>export DOCKER_DEFAULT_PLATFORM=\"amd64\"\n</code></pre>"},{"location":"docker/#running","title":"Running","text":"<p>Once everything is up and running, you can use the REST API to show the configured backends:</p> <pre><code>curl localhost:8080/api/public/backends\n</code></pre> <p>The Trino Gateway is available at http://localhost:8080.</p> <p>The PostgreSQL backend database for Trino Gateway runs on <code>localhost:5432</code>. You can query it for troubleshooting and other purposes using the credentials and details found in the <code>docker-compose.yml</code> file.</p>"},{"location":"docker/#configuration","title":"Configuration","text":"<p>The image uses the configuration file <code>docker/config.yaml</code> from the project checkout, and mounts it at <code>/etc/trino-gateway/config.yaml</code>.</p>"},{"location":"docker/#health-check","title":"Health check","text":"<p>By default the container health check uses the file <code>docker/bin/health-check</code> mounted at <code>/usr/lib/trino-gateway/bin/health-check</code>. The scripts expects a 2XX response from the server at <code>/api/public/backends</code>.</p>"},{"location":"docs/","title":"Documentation development","text":"<p>The Trino Gateway documentation uses markdown source files, MkDocs with the  material theme for rendering, and GitHub pages for hosting.</p> <p>The following sections contain minimal helpful tips to get started. More  details are available in the following resources:</p> <ul> <li>Material for MkDocs website</li> <li>MkDocs website</li> </ul>"},{"location":"docs/#writing-documentation","title":"Writing documentation","text":"<p>Content is written as markdown files in the <code>docs</code> folder.</p> <p>Writing style guidelines are identical to the Trino documentation and  website.</p> <p>Refer to the  reference docs from Material for MkDocs for syntax information.  </p>"},{"location":"docs/#running-site-locally","title":"Running site locally","text":"<p>Install <code>python</code> and <code>pipx</code>, for example with brew.</p> <p>Install <code>mkdocs-material</code> and all required dependencies in the <code>mkdocs-material</code>  virtual environment for Python:</p> <pre><code>pipx install --include-deps mkdocs-material \n</code></pre> <p>Add plugins to the virtual environment:</p> <pre><code>pipx inject --include-deps mkdocs-material cairosvg\n</code></pre> <p>Start the local site in the project root folder:</p> <pre><code>cd trino-gateway\nmkdocs serve\n</code></pre> <p>Access the site in your browser at http://127.0.0.1:8000/</p> <p>Edit the site sources as desired and refresh pages as needed. Some changes  require a restart of mkdocs.</p> <p>Alternatively, use a container to run mkdocs and avoid the need to install  mkdocs-material and all dependencies locally.</p> <pre><code>docker run --rm -it -v ${PWD}:/docs -p8000:8000 squidfunk/mkdocs-material \n</code></pre>"},{"location":"docs/#configuring-mkdocs","title":"Configuring MKDocs","text":"<p>MkDocs is configured in <code>mkdocs.yml</code>. Refer to the source, the  Material for MkDocs website  and the MkDocs website for more information.</p>"},{"location":"gateway-api/","title":"Gateway API","text":"<p>The REST API for Trino Gateway can be used to update routing configuration for the Trino clusters. Note that the API calls do not perform actions on the clusters themselves.</p> <p>The example commands are for a Trino Gateway server running at <code>http://localhost:8080</code>.</p> <p>If there are duplicate <code>proxyTo</code> URLs in the configuration, the <code>Name</code> in the Query History page of the UI might not show correctly.</p>"},{"location":"gateway-api/#create-a-trino-cluster","title":"Create a Trino cluster","text":"<pre><code>curl -X POST http://localhost:8080/gateway/backend/modify/add \\\n -H \"Content-Type: application/json\" \\\n -d '{  \"name\": \"trino-3\",\n        \"proxyTo\": \"http://localhost:8083\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\"\n    }'\n</code></pre> <p>If the Trino cluster URL is different from the <code>proxyTo</code> URL, for example if they are internal and external hostnames used, you can use the optional <code>externalUrl</code> field to override the link in the Active Backends page.</p> <pre><code>curl -X POST http://localhost:8080/gateway/backend/modify/add \\\n -H \"Content-Type: application/json\" \\\n -d '{  \"name\": \"trino-3\",\n        \"proxyTo\": \"http://localhost:8083\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8084\"\n    }'\n</code></pre>"},{"location":"gateway-api/#update-a-trino-cluster","title":"Update a Trino cluster","text":"<pre><code>curl -X POST http://localhost:8080/gateway/backend/modify/update \\\n -H \"Content-Type: application/json\" \\\n -d '{  \"name\": \"trino-3\",\n        \"proxyTo\": \"http://localhost:8083\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8084\"\n    }'\n</code></pre>"},{"location":"gateway-api/#list-all-trino-clusters","title":"List all Trino clusters","text":"<pre><code>curl -X GET http://localhost:8080/gateway/backend/all\n</code></pre> <p>Returns a JSON array of Trino cluster:</p> <pre><code>[\n    {\n        \"name\": \"trino-1\",\n        \"proxyTo\": \"http://localhost:8081\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8081\"\n    },\n    {\n        \"name\": \"trino-2\",\n        \"proxyTo\": \"http://localhost:8082\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8082\"\n    },\n    {\n        \"name\": \"trino-3\",\n        \"proxyTo\": \"http://localhost:8083\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8084\"\n    }\n]\n</code></pre>"},{"location":"gateway-api/#delete-a-trino-cluster","title":"Delete a Trino cluster","text":"<pre><code>curl -X POST -d \"trino3\" http://localhost:8080/gateway/backend/modify/delete\n</code></pre>"},{"location":"gateway-api/#deactivate-a-trino-cluster","title":"Deactivate a Trino cluster","text":"<pre><code>curl -X POST http://localhost:8080/gateway/backend/deactivate/trino-2\n</code></pre>"},{"location":"gateway-api/#list-all-active-trino-clusters","title":"List all active Trino clusters","text":"<pre><code>curl -X GET http://localhost:8080/gateway/backend/active\n</code></pre> <p>Returns a JSON array of active Trino clusters:</p> <pre><code>[\n    {\n        \"name\": \"trino-1\",\n        \"proxyTo\": \"http://localhost:8081\",\n        \"active\": true,\n        \"routingGroup\": \"adhoc\",\n        \"externalUrl\": \"http://localhost:8081\"\n    }\n]\n</code></pre>"},{"location":"gateway-api/#activate-a-trino-cluster","title":"Activate a Trino cluster","text":"<pre><code>curl -X POST http://localhost:8080/gateway/backend/activate/trino-2\n</code></pre>"},{"location":"gateway-api/#update-routing-rules","title":"Update routing rules","text":"<p>This endpoint is part of the <code>/webapp</code> endpoint family and requires the <code>ADMIN</code> role.</p> <p>The API can be used to programmatically update the routing rules. Rule are updated based on the rule name. Storage of the rules must use a writeable file and the configuration 'rulesType: FILE'.</p> <p>For this feature to work with multiple replicas of the Trino Gateway, you must provide a shared storage that supports file locking for the routing rules file. If multiple replicas are used with local storage, then rules get out of sync when updated.</p> <pre><code>curl -X POST http://localhost:8080/webapp/updateRoutingRules \\\n -H 'Content-Type: application/json' \\\n -d '{  \"name\": \"trino-rule\",\n        \"description\": \"updated rule description\",\n        \"priority\": 0,\n        \"actions\": [\"updated action\"],\n        \"condition\": \"updated condition\"\n    }'\n</code></pre>"},{"location":"installation/","title":"Installation","text":"<p>Trino Gateway is distributed as an executable JAR file. The release notes contain links to download specific versions.</p> <p>Every Trino Gateway release includes a Docker container and a  Helm chart as alternative deployment methods.</p> <p>Follow the development instructions to build the JAR file and the Docker image instructions  or use the  <code>TrinoGatewayRunner</code> class for local testing. The quickstart guide contains instructions for running the application locally.</p> <p>Following are instructions for installing Trino Gateway for production environments.</p>"},{"location":"installation/#requirements","title":"Requirements","text":"<p>Consider the following requirements for your Trino Gateway installation.</p>"},{"location":"installation/#java","title":"Java","text":"<p>Trino Gateway requires a Java 25 runtime. Older versions of Java can not be used. Newer versions might work but are not tested.</p> <p>Verify the Java version on your system with <code>java -version</code>.</p>"},{"location":"installation/#operating-system","title":"Operating system","text":"<p>No specific operating system is required. All testing and development is performed with Linux and MacOS.</p>"},{"location":"installation/#processor-architecture","title":"Processor architecture","text":"<p>No specific processor architecture is required, as long as a suitable Java distribution is installed.  </p>"},{"location":"installation/#backend-database","title":"Backend database","text":"<p>Trino Gateway requires a MySQL, PostgreSQL, or Oracle database. Database initialization is performed automatically when the Trino Gateway process starts. Migrations are performed using <code>Flyway</code>.</p> <p>The migration files can viewed in the <code>gateway-ha/src/main/resources/</code> folder. Each database type supported has its own sub-folder.</p> <p>The files are also included in the JAR file.</p> <p>If you do not want migrations to be performed automatically on startup, then you can set <code>runMigrationsEnabled</code> to <code>false</code> in the data store configuration.</p> <p>You can also disable query history recording to the database by setting <code>queryHistoryEnabled</code> to <code>false</code>. This can be useful in scenarios where you want to reduce database load or don't need query history tracking.</p> <p>For example:</p> <pre><code>dataStore:\n  jdbcUrl: jdbc:postgresql://postgres:5432/trino_gateway_db\n  user: USER\n  password: PASSWORD\n  driver: org.postgresql.Driver\n  queryHistoryHoursRetention: 24\n  runMigrationsEnabled: false\n  queryHistoryEnabled: true  # Set to false to disable query history recording\n</code></pre> <p><code>Flyway</code> uses a transactional lock in databases that support it such as  PostgreSQL. In the scenario where multiple Trino Gateway instances are running and sharing the same backend database, the first Trino Gateway instance to start will get the lock and run the database migrations with <code>Flyway</code>. Other Trino Gateway instances might fail during startup while migrations are running but once migrations are completed they will start as expected.</p>"},{"location":"installation/#trino-clusters","title":"Trino clusters","text":"<p>The proxied Trino clusters behind the Trino Gateway must support the Trino JDBC driver and the Trino REST API for cluster and node health information. Typically, this means that Trino versions 354 and higher should work, however newer Trino versions are strongly recommended.</p> <p>Trino-derived projects and platforms may work if the Trino JDBC driver and the REST API are supported. For example, Starburst Galaxy and Starburst Enterprise are known to work. Trino deployments with the Helm chart and other means on various cloud platforms, such as Amazon EKS also work. However Amazon Athena does not work since it uses alternative, custom protocols and lacks the concept of individual clusters.</p>"},{"location":"installation/#trino-configuration","title":"Trino configuration","text":"<p>From a users perspective Trino Gateway acts as a transparent proxy for one  or more Trino clusters. The following Trino configuration tips should be  taken into account for all clusters behind the Trino Gateway.</p> <p>If all client and server communication is routed through Trino Gateway,  then process forwarded HTTP headers must be enabled:</p> <pre><code>http-server.process-forwarded=true\n</code></pre> <p>Without this setting, first requests go from the user to Trino Gateway and then to Trino correctly. However, the URL for subsequent next URIs for more results in a query provided by Trino is then using the local URL of the Trino cluster, and not the URL of the Trino Gateway. This circumvents the Trino Gateway for all these requests. In scenarios, where the local URL of the Trino cluster is private  to the Trino cluster on the network level, these following calls do not work at all for users.</p> <p>This setting is also required for Trino to authenticate in the case TLS is  terminated at the Trino Gateway. Normally it refuses to authenticate plain HTTP  requests, but if <code>http-server.process-forwarded=true</code> it authenticates over  HTTP if the request includes <code>X-Forwarded-Proto: HTTPS</code>.</p> <p>To prevent Trino Gateway from sending <code>X-Forwarded-*</code> headers, add the following configuration:</p> <pre><code>routing:\n  addXForwardedHeaders: false\n</code></pre> <p>Find more information in the related Trino documentation.</p>"},{"location":"installation/#configuration","title":"Configuration","text":"<p>After downloading or building the JAR, rename it to <code>gateway-ha.jar</code>, and place it in a directory with read and write access such as <code>/opt/trinogateway</code>.</p> <p>Copy the example config file <code>config.yaml</code> from the <code>gateway-ha/</code> directory into the same directory, and update the configuration as needed.</p> <p>Each component of the Trino Gateway has a corresponding node in the configuration YAML file.</p>"},{"location":"installation/#secrets-in-configuration-file","title":"Secrets in configuration file","text":"<p>Environment variables can be used as values in the configuration file. You can manually set an environment variable on the command line.</p> <pre><code>export DB_PASSWORD=my-super-secret-pwd\n</code></pre> <p>To use this variable in the configuration file, you reference it with the  syntax <code>${ENV:VARIABLE}</code>. For example:</p> <pre><code>dataStore:\n  jdbcUrl: jdbc:postgresql://localhost:5432/gateway\n  user: postgres\n  password: ${ENV:DB_PASSWORD}\n</code></pre>"},{"location":"installation/#configure-routing-rules","title":"Configure routing rules","text":"<p>Find more information in the routing rules documentation.</p>"},{"location":"installation/#configure-logging","title":"Configure logging  <p>To configure the logging level for various classes, specify the path to the  <code>log.properties</code> file by setting <code>log.levels-file</code> in <code>serverConfig</code>.</p> <p>For additional configurations, use the <code>log.*</code> properties from the  Trino logging properties documentation and specify the properties in <code>serverConfig</code>.</p>","text":""},{"location":"installation/#proxying-additional-paths","title":"Proxying additional paths <p>By default, Trino Gateway only proxies requests to paths starting with <code>/v1/statement</code>, <code>/v1/query</code>, <code>/ui</code>, <code>/v1/info</code>, <code>/v1/node</code>, <code>/ui/api/stats</code> and <code>/oauth</code>.</p> <p>If you want to proxy additional paths, you can add them by adding the <code>extraWhitelistPaths</code> node to your configuration YAML file. Trino Gateway takes regexes from <code>extraWhitelistPaths</code> and forwards only those requests with a URI that exactly match. Be sure to use single-quoted strings so that escaping is not required.</p> <pre><code>extraWhitelistPaths:\n  - '/ui/insights'\n  - '/api/v1/biac'\n  - '/api/v1/dataProduct'\n  - '/api/v1/dataproduct'\n  - '/api/v2/.*'\n  - '/ext/faster'\n</code></pre>","text":""},{"location":"installation/#configure-additional-v1statement-like-paths","title":"Configure additional v1/statement-like paths <p>The Trino client protocol specifies that queries are initiated by a POST to <code>v1/statement</code>.  The Trino Gateway incorporates this into its routing logic by extracting and recording the  query id from responses to such requests. If you use an experimental or commercial build of Trino that supports additional endpoints, you can cause Trino Gateway to treat them  equivalently to <code>/v1/statement</code> by adding them under the <code>additionalStatementPaths</code> configuration node. They must be absolute, and no path can be a prefix to any other path. The standard <code>/v1/statement</code> path is always included and does not need to be configured.  For example:</p> <pre><code>additionalStatementPaths:\n  - '/ui/api/insights/ide/statement'\n  - '/v2/statement'\n</code></pre>","text":""},{"location":"installation/#deactivate-ui-pages","title":"Deactivate UI pages <p>You can set the <code>disablePages</code> configuration to deactivate UI pages.</p> <pre><code>uiConfiguration:\n  disablePages:\n    - 'routing-rules'\n</code></pre> <p>The following pages are available:</p> <ul> <li><code>dashboard</code></li> <li><code>cluster</code></li> <li><code>resource-group</code></li> <li><code>selector</code></li> <li><code>history</code></li> <li><code>routing-rules</code></li> </ul>","text":""},{"location":"installation/#configure-behind-a-load-balancer","title":"Configure behind a load balancer","text":"<p>A possible deployment of Trino Gateway is to run multiple instances of Trino  Gateway behind another generic load balancer, such as a load balancer from  your cloud hosting provider. In this deployment you must configure the  <code>serverConfig</code> to include enabling process forwarded HTTP headers:</p> <pre><code>serverConfig:\n  http-server.process-forwarded: true\n</code></pre>"},{"location":"installation/#configure-larger-proxy-response-size","title":"Configure larger proxy response size","text":"<p>Trino Gateway reads the response from Trino in bytes (up to 32MB by default). It can be configured by setting:</p> <pre><code>proxyResponseConfiguration:\n  responseSize: 50MB\n</code></pre>"},{"location":"installation/#running-trino-gateway","title":"Running Trino Gateway","text":"<p>Start Trino Gateway with the following java command in the directory of the JAR and YAML files:</p> <pre><code>java -XX:MinRAMPercentage=50 -XX:MaxRAMPercentage=80 \\\n    -jar gateway-ha.jar config.yaml\n</code></pre>"},{"location":"installation/#helm","title":"Helm  <p>Helm manages the deployment of Kubernetes applications by templating Kubernetes resources with a set of Helm charts. The Trino Gateway Helm chart is  available in the Trino Helm chart project.</p> <p>Configure the charts repository as a Helm chart repository with the  following command:</p> <p><pre><code>helm repo add trino https://trinodb.github.io/charts/\n</code></pre> The Trino Gateway chart consists of the following components:</p> <ul> <li>A <code>config</code> node for general configuration</li> <li><code>dataStoreSecret</code>, <code>backendStateSecret</code> and <code>authenticationSecret</code> for    providing sensitive configurations through Kubernetes secrets, </li> <li>Standard Helm options such as <code>replicaCount</code>, <code>resources</code> and <code>ingress</code>.</li> </ul> <p>The default <code>values.yaml</code> found in the <code>helm/trino-gateway</code> folder includes basic configuration options as an example. For a simple deployment, proceed with  the following steps:</p> <p>Create a yaml file containing the configuration for your <code>datastore</code>:</p> <p><pre><code>cat &lt;&lt; EOF &gt; datastore.yaml\ndataStore:\n   jdbcUrl: jdbc:postgresql://yourdatabasehost:5432/gateway\n   user: postgres\n   password: secretpassword\n   driver: org.postgresql.Driver\nEOF\n</code></pre> Create a Kubernetes secret from this file:</p> <pre><code>kubectl create secret generic datastore-yaml --from-file datastore.yaml --dry-run=client -o yaml | kubectl apply -f -\n</code></pre> <p>Create a values override with a name such as <code>values-override.yaml</code> and reference this secret in the <code>backendStateSecret</code> node:</p> <pre><code>backendStateSecret:\n    name: \"datastore-yaml\"\n    key: \"datastore.yaml\"\n</code></pre> <p>When a Secret is created with the <code>--from-file</code> option, the filename is used as the key. Finally, you can deploy Trino Gateway with the chart from the root  of this repository:</p> <pre><code>helm install tg --values values-override.yaml trino/trino-gateway \n</code></pre> <p>Secrets for <code>authenticationSecret</code> and <code>backendState</code> can be provisioned similarly. Alternatively,  you can directly define the <code>config.backEndState</code>  node in <code>values-override.yaml</code> and leave <code>backendStateSecret</code> undefined.  However, a Secret is recommended to protect the database credentials required for this  configuration.</p> <p>By default, the Trino Gateway process is started with the following command:</p> <pre><code>java -XX:MinRAMPercentage=80.0 -XX:MaxRAMPercentage=80.0 -jar /usr/lib/trino-gateway/gateway-ha-jar-with-dependencies.jar /etc/trino-gateway/config.yaml\n</code></pre> <p>You can customize details with the <code>command</code> node. It accepts a list, that must begin with an executable such as <code>java</code> or <code>bash</code> that is available on the PATH. The following list elements are provided as arguments to the executable. It is not typically necessary to modify this node. You can use it to change of JVM startup parameters to control memory settings and other aspects, or to use other configuration file names.</p>","text":""},{"location":"installation/#additional-options","title":"Additional options","text":"<p>To implement routing rules, create a ConfigMap from your routing rules yaml definition:</p> <pre><code>kubectl create cm routing-rules --from-file your-routing-rules.yaml\n</code></pre> <p>Then mount it to your container:</p> <pre><code>volumes:\n    - name: routing-rules\n      configMap:\n          name: routing-rules\n          items:\n              name: your-routing-rules.yaml\n              path: your-routing-rules.yaml\n\nvolumeMounts:\n    - name: routing-rules\n      mountPath: \"/etc/routing-rules/your-routing-rules.yaml\"\n      subPath: your-routing-rules.yaml\n</code></pre> <p>Ensure that the <code>mountPath</code> matches the <code>rulesConfigPath</code> specified in your configuration. Note that the <code>subPath</code> is not strictly necessary, and if it  is not specified the file is mounted at <code>mountPath/&lt;configMap key&gt;</code>.  Kubernetes updates the mounted file when the ConfigMap is updated.</p> <p>Standard Helm options such as <code>replicaCount</code>, <code>image</code>, <code>imagePullSecrets</code>,  <code>service</code>, <code>ingress</code> and <code>resources</code> are supported. These are defined in  <code>helm/values.yaml</code>. </p> <p>More detail about the chart are available in the values  reference documentation</p>"},{"location":"installation/#health-checks-on-trino-clusters","title":"Health checks on Trino clusters <p>The Trino Gateway periodically performs health checks and maintains an in-memory TrinoStatus for each backend. If a backend fails a health check, it is marked as UNHEALTHY, and the Trino Gateway stops routing requests to it.</p> <p>It is important to distinguish TrinoStatus from the active/inactive state of a backend. The active/inactive state indicates whether a backend is manually turned on or off, whereas TrinoStatus is programmatically determined by the health check process.</p> <p>See TrinoStatus for more details on  what each Trino status means.</p> <p>Username and password for the health check can be configured by adding  <code>backendState</code> to your configuration. The username and password must be valid across all backends.</p> <p>SSL and xForwardProtoHeader can be configured based on whether the  connection between the Trino Gateway and the backend is secure.  By default, both are set to false. Find more information in the related Trino documentation.</p> <pre><code>backendState:\n  username: \"user\"\n  password: \"password\"\n  ssl: &lt;false/true&gt;\n  xForwardedProtoHeader: &lt;false/true&gt;  \n</code></pre> <p>The type of health check is configured by setting</p> <pre><code>clusterStatsConfiguration:\n  monitorType: \"\"\n</code></pre> <p>to one of the following values.</p>","text":""},{"location":"installation/#info_api-default","title":"INFO_API (default)","text":"<p>By default Trino Gateway uses the <code>v1/info</code> REST endpoint. A successful check is defined as a 200 response with <code>starting: false</code>. Connection timeout parameters  can be defined through the <code>monitor</code> node, for example</p> <pre><code>monitor:\n  connectTimeoutSeconds: 5\n  requestTimeoutSeconds: 10\n  idleTimeoutSeconds: 1\n  retries: 1\n</code></pre> <p>All timeout parameters are optional.</p>"},{"location":"installation/#metrics","title":"METRICS","text":"<p>This pulls statistics from Trino's OpenMetrics endpoint. It retrieves the number of running and queued queries for use with the <code>QueryCountBasedRouter</code> (either <code>METRICS</code> or <code>JDBC</code> must be enabled if <code>QueryCountBasedRouter</code> is used).</p> <p>By default, it uses the <code>trino_execution_name_QueryManager_RunningQueries</code> and <code>trino_execution_name_QueryManager_QueuedQueries</code> to track the number of running and queued queries respectively, however these metrics can be configured as follows:</p> <pre><code>monitor:\n    runningQueriesMetricName: io_starburst_galaxy_name_GalaxyMetrics_RunningQueries\n    queuedQueriesMetricName: io_starburst_galaxy_name_GalaxyMetrics_QueuedQueries\n</code></pre> <p>Similarly, by default the monitor pulls the metrics using the <code>/metrics</code> endpoint, but it can be updated to use another one:</p> <pre><code>monitor:\n    metricsEndpoint: /v1/metrics\n</code></pre> <p>This monitor allows customizing health definitions by comparing metrics to fixed values. This is configured through two maps: <code>metricMinimumValues</code> and  <code>metricMaximumValues</code>. The keys of these maps are the metric names, and the values are the minimum or maximum values (inclusive) that are considered healthy. By default, the only metric populated is:</p> <pre><code>monitor:\n    metricMinimumValues:\n        trino_metadata_name_DiscoveryNodeManager_ActiveNodeCount: 1\n</code></pre> <p>This requires the cluster to have at least one active worker node in order to be considered healthy. The map is overwritten if configured explicitly. For example, to increase the minimum worker count to 10 and disqualify clusters that have been experiencing frequent major Garbage Collections, set</p> <pre><code>monitor:\n    metricMinimumValues:\n        trino_metadata_name_DiscoveryNodeManager_ActiveNodeCount: 10\n    metricMaximumValues:\n        io_airlift_stats_name_GcMonitor_MajorGc_FiveMinutes_count: 2\n</code></pre>"},{"location":"installation/#jdbc","title":"JDBC","text":"<p>This uses a JDBC connection to query <code>system.runtime</code> tables for cluster  information. It is required for the query count based routing strategy. This is recommended over <code>UI_API</code> since it does not restrict the Web UI authentication method of backend clusters. </p> <p>Trino Gateway uses <code>explicitPrepare=false</code> by default. This property was introduced in Trino 431, and uses a single query for prepared statements, instead of a  <code>PREPARE/EXECUTE</code> pair. If you are using the JDBC health check option with older  versions of Trino, set <pre><code>monitor:\n   explicitPrepare: true\n</code></pre></p> <p>The query timeout can be set through</p> <pre><code>monitor:\n    queryTimeout: 10\n</code></pre> <p>Other timeout parameters are not applicable to the JDBC connection.</p>"},{"location":"installation/#jmx","title":"JMX","text":"<p>The monitor type <code>JMX</code> can be used as an alternative to collect cluster information,  which is required for the <code>QueryCountBasedRouterProvider</code>. This uses the <code>v1/jmx/mbean</code>  endpoint on Trino clusters.</p> <p>To enable this:</p> <p>JMX monitoring must be activated on all Trino clusters with:</p> <pre><code>jmx.rmiregistry.port=&lt;port&gt;\njmx.rmiserver.port=&lt;port&gt;\n</code></pre> <p>Allow JMX endpoint access by adding rules to your file-based access control configuration. Example for <code>user</code>:</p> <pre><code>{  \n  \"catalogs\": [\n    {\n      \"user\": \"user\",\n      \"catalog\": \"system\",\n      \"allow\": \"read-only\"\n    }\n  ],\n  \"system_information\": [\n    {\n      \"user\": \"user\",\n      \"allow\": [\"read\"]\n    }\n  ]\n}\n</code></pre> <p>Ensure that a username and password are configured by adding the <code>backendState</code> section to your configuration. The credentials must be consistent across all backend clusters and have <code>read</code> rights on the <code>system_information</code>.</p> <pre><code>backendState:\n  username: \"user\"\n  password: \"password\"\n</code></pre> <p>The JMX monitor will use these credentials to authenticate against the JMX endpoint of each Trino cluster and collect metrics like running queries, queued queries, and worker nodes information.</p>"},{"location":"installation/#ui_api","title":"UI_API","text":"<p>This pulls cluster information from the <code>ui/api/stats</code> REST endpoint. This is supported for legacy reasons and may be deprecated in the future. It is only  supported for backend clusters with <code>web-ui.authentication.type=FORM</code>. Set a username and password using <code>backendState</code> as with the <code>JDBC</code> option.</p>"},{"location":"installation/#noop","title":"NOOP","text":"<p>This option disables health checks.</p>"},{"location":"migration-to-airlift/","title":"Migration to Airlift","text":"<p>The codebase of Trino Gateway has been heavily upgraded to meet the Trino standards. Dropwizard and Jetty Proxy has been replaced by Airbase and Airlift. This page documents the incompatible changes and aims to smooth the migration. The migration is only required for user using Trino Gateway before version 10.</p>"},{"location":"migration-to-airlift/#change-of-endpoints","title":"Change of endpoints","text":"<p>You have to make the following adjustments to take the change to using only one HTTP port into account.</p>"},{"location":"migration-to-airlift/#merge-of-service-ports","title":"Merge of service ports","text":"<p>Multiple service ports have been merged together. The old version listens to multiple ports: request service at port 9080, application service at port 9081, and the Admin service at port 9082. The new version only listens to one single port at 8080 by default.</p>"},{"location":"migration-to-airlift/#merge-of-request-service-and-application-service","title":"Merge of request service and application service","text":"<p>Requests to the Trino Gateway (Web UI and RESTful API) and requests that need to be forwarded to Trino are both served by the same port. The destination is determined by the HTTP URI in the request.</p>"},{"location":"migration-to-airlift/#removal-of-the-dropwizard-admin-service-at-port-9082","title":"Removal of the Dropwizard admin service at port 9082","text":"<p>The admin console page provided by Dropwizard (port 9082) has been removed. JMX can be viewed at <code>/v1/jmx</code>. There are no plans to support other functions on the Dropwizard Admin page (metrics, ping, threads, healthcheck, CPU profile, and CPU contention).</p>"},{"location":"migration-to-airlift/#path-change-for-webui","title":"Path change for WebUI","text":"<p>The root path for Trino Gateway WebUI has been changed from <code>/</code> to <code>/trino-gateway</code>. By default, access to <code>/</code> is redirected to <code>/trino-gateway</code>. This behavior can be changed by adding <code>/</code> to <code>extraWhitelistPaths</code>, which results in routing <code>/</code> to Trino.</p>"},{"location":"migration-to-airlift/#change-of-configuration","title":"Change of configuration","text":"<p>You must adjust your configuration to the following changes.</p>"},{"location":"migration-to-airlift/#change-of-service-ports","title":"Change of service ports","text":"<p><code>requestRouter</code>, <code>server</code>, <code>applicationConnectors</code>, and <code>adminConnectors</code> are replaced by <code>serverConfig</code>.</p> <p>Old config: <pre><code>requestRouter:\n    port: 8080\n    name: trinoRouter\n    historySize: 1000\n    requestBufferSize: 8192\nserver:\n    applicationConnectors:\n        - type: http\n          port: 8090\n          useForwardedHeaders: true\n    adminConnectors:\n        - type: http\n          port: 8091\n          useForwardedHeaders: true\n</code></pre></p> <p>New config: <pre><code>serverConfig:\n    node.environment: test\n    http-server.http.port: 8443\n    proxy.http-client.request-buffer-size: 8kB\n</code></pre></p>"},{"location":"migration-to-airlift/#tls-configuration","title":"TLS configuration","text":"<p><code>ssl</code>, <code>keystorePath</code>, and <code>keystorePass</code> are replaced by <code>http-server.https.*</code>. For more details, see Security</p> <p>Old config: <pre><code>requestRouter:\n  ssl: true\n  port: 8080\n  name: trinoRouter\n  historySize: 1000\n  keystorePath: &lt;path&gt;\n  keystorePass: &lt;password&gt;\n\nserver:\n  applicationConnectors:\n    - type: https\n      port: 8090\n      keyStorePath: &lt;path&gt;\n      keyStorePassword: &lt;password&gt;\n      useForwardedHeaders: true\n  adminConnectors:\n    - type: https\n      port: 8091\n      keyStorePath: &lt;path&gt;\n      keyStorePassword: &lt;password&gt;\n      useForwardedHeaders: true\n</code></pre></p> <p>New config: <pre><code>serverConfig:\n    http-server.http.enabled: false\n    http-server.https.enabled: true\n    http-server.https.port: 8080\n    http-server.https.keystore.path: &lt;path&gt;\n    http-server.https.keystore.key: &lt;password&gt;\n</code></pre></p>"},{"location":"migration-to-airlift/#logging","title":"Logging","text":"<p>Old config:</p> <ul> <li>Set logging to external <pre><code>logging:\n    type: external\n</code></pre></li> <li>Also specify the path to the <code>log.properties</code> file using the <code>log.levels-file</code>   JVM options, such as <code>-Dlog.levels-file=etc/log.properties</code>.</li> </ul> <p>New config:</p> <ul> <li>Specify the path to the <code>log.properties</code> file in config <pre><code>serverConfig:\n    log.levels-file: gateway-ha/etc/log.properties\n</code></pre></li> <li>The <code>log.levels-file</code> JVM option is no longer supported.</li> </ul>"},{"location":"migration-to-airlift/#jvm-startup-arguments","title":"JVM startup arguments","text":"<p>The first arg <code>server</code> has been removed.</p> <p>Old config: <pre><code>java -jar gateway-ha.jar server config.yaml\n</code></pre></p> <p>New config: <pre><code>java -jar gateway-ha.jar config.yaml\n</code></pre></p>"},{"location":"migration-to-airlift/#format-of-extrawhitelistpaths","title":"Format of <code>extraWhitelistPaths</code>","text":"<p>The path setting in <code>extraWhitelistPaths</code> is now a regex that matches the full URI in the request. The old version forwards requests with a URI prefix that matches any path in <code>extraWhitelistPaths</code>. The new version takes regexes from <code>extraWhitelistPaths</code> and forwards only those requests with a URI that exactly matches any of the regexes. This change is required because in the old version, <code>/</code> matches and forwards every request.</p> <p>Be sure to use single-quoted strings so that escaping is not required. The following configurations are equivalent.</p> <p>Old config: <pre><code>extraWhitelistPaths:\n    - \"/ui\"\n    - \"/v1/custom\"\n</code></pre></p> <p>New config: <pre><code>extraWhitelistPaths:\n    - '/ui.*'\n    - '/v1/custom.*'\n</code></pre></p>"},{"location":"migration-to-airlift/#jvm-options","title":"JVM options","text":"<p>The following JVM options are no longer required:</p> <pre><code>-Dlog.levels-file=XXX\n--add-opens=java.base/java.lang=ALL-UNNAMED\n--add-opens=java.base/java.net=ALL-UNNAMED\n</code></pre>"},{"location":"migration-to-airlift/#miscellaneous-changes","title":"Miscellaneous changes","text":"<p>The following section details a number of other changes.</p>"},{"location":"migration-to-airlift/#use-port-8080-and-8443","title":"Use port 8080 and 8443","text":"<p>Use port 8080 for HTTP and 8443 for HTTPS in all the documentations, Docker image and example config file. The use of the ports 9080, 9081, 9082 has been removed. This enhances the consistency throughout the project.</p>"},{"location":"migration-to-airlift/#request-logging","title":"Request logging","text":"<p><code>dropwizard-request-logging</code> has been removed. Airlift provides logging for the  HTTP requests. See Logging properties  for configuration.</p>"},{"location":"operation/","title":"Operation","text":"<p>The following aspects apply to managing Trino Gateway and the connected Trino clusters.</p>"},{"location":"operation/#query-history-ui-check-query-plans-etc","title":"Query History UI - check query plans etc.","text":"<p>Trino Gateway records history of recent queries and displays links to check query details page in respective trino cluster. </p>"},{"location":"operation/#cluster-ui-add-and-modify-cluster-information","title":"Cluster UI - add and modify cluster information","text":"<p>The cluster page is used to configure Trino Gateway for multiple Trino clusters. Existing cluster information can also be modified using the edit button.</p> <p></p>"},{"location":"operation/#graceful-shutdown","title":"Graceful shutdown","text":"<p>Trino Gateway supports graceful shutdown of Trino clusters. Even when a cluster is deactivated, any submitted query states can still be retrieved based on the Query ID.</p> <p>To graceful shutdown a trino cluster without query losses, the steps are:</p> <ol> <li>Deactivate the cluster by turning off the 'Active' switch. This ensures that no     new incoming queries are routed to the cluster.</li> <li>Poll the Trino cluster coordinator URL until the queued query count and the    running query count are both zero.</li> <li>Terminate the Trino coordinator and worker Java processes.</li> </ol> <p>To gracefully shutdown a single worker process, refer to the Trino  documentation for more details.</p>"},{"location":"operation/#query-routing-options","title":"Query routing options","text":"<ul> <li>The default router selects the cluster randomly to route the queries. </li> <li>If you want to route the queries to the least loaded cluster for a user   so the cluster with the fewest running or queued queries, use <code>QueryCountBasedRouter</code>. You can enable it by adding the module name  to the <code>modules</code> section of the config file:</li> </ul> <p><pre><code>modules:\n  - io.trino.gateway.ha.module.QueryCountBasedRouterProvider\n</code></pre> - The router operates based on the stats it receives from the clusters, such as  the number of queued and running queries. These values are retrieved at regular  intervals. This interval can be configured by setting <code>taskDelay</code> under <code>monitor</code> section in the config file. The default interval is 1 minute <pre><code>monitor:\n  taskDelay: 1m\n</code></pre></p>"},{"location":"operation/#monitoring","title":"Monitoring","text":"<p>Trino Gateway provides a metrics endpoint that uses the OpenMetrics format at  <code>/metrics</code>. Use it to monitor Trino Gateway instances with Prometheus and  other compatible systems with the following Prometheus configuration:</p> <pre><code>scrape_configs:\n- job_name: trino_gateway\n  static_configs:\n    - targets:\n        - gateway1.example.com:8080\n</code></pre>"},{"location":"operation/#trino-gateway-health-endpoints","title":"Trino Gateway health endpoints","text":"<p>Trino Gateway provides two API endpoints to indicate the current status of the server:</p> <ul> <li><code>/trino-gateway/livez</code> always returns status code 200, indicating the server is alive. However, it might not respond if the Trino Gateway is too busy, stuck, or taking a long time for garbage collection.</li> <li><code>/trino-gateway/readyz</code> returns status code 200, indicating the server has completed initialization and is ready to serve requests. This means the initial connection to the database and the first round of health check on Trino clusters are completed. Otherwise, status code 503 is returned.</li> </ul>"},{"location":"operation/#database-cache-configuration","title":"Database cache configuration","text":"<p>Trino Gateway can cache database queries to improve performance and reduce load on the backend database. This also allow gateway to continue routing queries when the database is temporarily unavailable. Currently only the list of backend Trino clusters used for query routing are being cached. The cache can be configured using the <code>databaseCache</code> section in the config file.</p> <pre><code>databaseCache:\n  enabled: true\n  expireAfterWrite: 1h\n  refreshAfterWrite: 5s\n</code></pre> <p>Configuration options:</p> <ul> <li><code>enabled</code> - Enable or disable the database cache. Default is <code>false</code>.</li> <li><code>expireAfterWrite</code> - The maximum time a cached entry is kept since it was last   loaded or refreshed. This ensures stale data is eventually removed.   If cache is not refreshed before expiration, requests will fail once the entry   expires (i.e. cache miss will attempt to reload data, but if the database is unavailable,   the request fails because there is no stale value to fall back to after   expiration). Default value is <code>1h</code>.</li> <li><code>refreshAfterWrite</code> - Duration after which cache entries are eligible for   asynchronous refresh. When a refresh is triggered, the existing cached value   continues to be served while the refresh happens in the background.   This helps keep data fresh while serving slightly stale data to avoid blocking requests.   Default value is <code>5s</code>.</li> </ul> <p><code>expireAfterWrite</code> and <code>refreshAfterWrite</code> can be set to <code>null</code> to disable expiration or refresh respectively.</p>"},{"location":"quickstart/","title":"Quickstart","text":"<p>The scripts from this quickstart guide set up a local environment consisting of two Trino servers and a PostgreSQL database running in Docker, and a Trino Gateway server running in the host operating system. </p>"},{"location":"quickstart/#start-trino-gateway-server","title":"Start Trino Gateway server","text":"<p>The following script starts a Trino Gateway server using the  Quickstart configuration at http://localhost:8080. It also starts a dockerized PostgreSQL database at localhost:5432.</p> <p>To start the server, copy the script below to a temporary directory  under the project root folder, and run it at the temporary directory.</p> <p>It  copies the following, necessary files to current directory:</p> <ul> <li><code>gateway-ha.jar</code> from Maven Central using the version specified in the script</li> <li><code>config.yaml</code> from the <code>docs</code> folder of the current project folder</li> </ul> <pre><code>#!/usr/bin/env sh\n\nVERSION=17\nBASE_URL=\"https://repo1.maven.org/maven2/io/trino/gateway/gateway-ha\"\nJAR_FILE=\"gateway-ha-$VERSION-jar-with-dependencies.jar\"\nGATEWAY_JAR=\"gateway-ha.jar\"\nCONFIG_YAML=\"config.yaml\"\n\n# Copy necessary files\ncopy_files() {\n    if [[ ! -f \"$GATEWAY_JAR\" ]]; then\n        echo \"Fetching $GATEWAY_JAR version $VERSION\"\n        curl -O \"$BASE_URL/$VERSION/$JAR_FILE\"\n        mv \"$JAR_FILE\" \"$GATEWAY_JAR\"\n    fi\n\n    [[ ! -f \"$CONFIG_YAML\" ]] &amp;&amp; cp ../docs/$CONFIG_YAML .\n}\n\n# Start PostgreSQL database if not running\nstart_postgres_db() {\n    if ! docker ps --format '{{.Names}}' | grep -q '^local-postgres$'; then\n        echo \"Starting PostgreSQL database container\"\n        PGPASSWORD=mysecretpassword\n        docker run -v \"$PWD/$POSTGRES_SQL:/tmp/$POSTGRES_SQL\" \\\n            --name local-postgres -p 5432:5432 -e POSTGRES_PASSWORD=$PGPASSWORD -d postgres\n        sleep 5\n        docker exec local-postgres psql -U postgres -h localhost -c 'CREATE DATABASE gateway'\n    fi\n}\n\n# Main execution flow\ncopy_files\nstart_postgres_db\n\n# Start Trino Gateway server\necho \"Starting Trino Gateway server...\"\njava -Xmx1g -jar ./$GATEWAY_JAR ./$CONFIG_YAML\n</code></pre> <p>You can clean up by running</p> <pre><code>docker kill local-postgres &amp;&amp; docker rm local-postgres\nkill -5 $(jps | grep gateway-ha.jar | cut -d' ' -f1)\n</code></pre>"},{"location":"quickstart/#add-trino-backends","title":"Add Trino backends","text":"<p>This following script starts two dockerized Trino servers at  http://localhost:8081 and http://localhost:8082. It then adds them as backends to the Trino Gateway server started by the preceding script.</p> <pre><code>#!/usr/bin/env sh\n\nTRINO_IMAGE=\"trinodb/trino\"\nJAVA_OPTS=\"-Dhttp-server.process-forwarded=true\"\n\n# Start Trino servers\nfor i in 1 2; do\n    PORT=808$i\n    if ! lsof -i:$PORT &gt; /dev/null; then\n        docker run --name trino$i -d -p $PORT:8080 \\\n            -e JAVA_TOOL_OPTIONS=\"$JAVA_OPTS\" $TRINO_IMAGE\n    else\n        echo \"Warning: Port $PORT is already in use. Skipping trino$i.\"\n    fi\ndone\n\n# Add Trino servers as Gateway backends\nadd_backend() {\n    curl -H \"Content-Type: application/json\" -X POST \\\n        localhost:8080/gateway/backend/modify/add \\\n        -d \"{\n              \\\"name\\\": \\\"$1\\\",\n              \\\"proxyTo\\\": \\\"http://localhost:808$2\\\",\n              \\\"active\\\": true,\n              \\\"routingGroup\\\": \\\"adhoc\\\"\n            }\"\n}\n\n# Adding Trino servers as backends\nfor i in 1 2; do\n    add_backend \"trino$i\" \"$i\"\ndone\n</code></pre> <p>You can clean up by running</p> <pre><code>docker kill trino1 &amp;&amp; docker rm trino1\ndocker kill trino2 &amp;&amp; docker rm trino2\n</code></pre>"},{"location":"release-notes/","title":"Release notes","text":""},{"location":"release-notes/#2026","title":"2026","text":""},{"location":"release-notes/#17","title":"Trino Gateway 17 (31 Jan 2026)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-17-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:17</code></li> <li>Source code as   tar.gz   or zip</li> <li>Trino Helm chart <code>trino/trino-gateway</code> version <code>1.17.0</code></li> </ul> <p>Changes:</p> <p>General</p> <ul> <li>Use UBI10 micro as the base Docker image.   (#779)</li> <li>Expose Trino cluster state via JMX.   (#782)</li> <li>Check health status for all clusters regardless of activation status.   (#809)</li> <li> Breaking change: Require Java 25 to run Trino Gateway   and use it in the container image.   (#802)</li> <li>Remove defunct email notifier.   (#843)</li> <li>Fix <code>partialCancel</code> statement path redirection.   (#776)</li> <li>Fix issues with large HTTP headers by setting <code>max-request-header-size</code> and   <code>max-response-header-size</code> parameters for HTTP client connections.   (#571)</li> </ul> <p>UI</p> <ul> <li>Display a truncated query text in the query history list.   (#806)</li> <li>Use and require Node.js v24.   (#813)</li> <li>Fix incorrect display of zero queries in the query distribution chart.   (#788)</li> </ul> <p>More details and a list of all merged pull requests are available in the milestone 17 list.</p>"},{"location":"release-notes/#2025","title":"2025","text":""},{"location":"release-notes/#16","title":"Trino Gateway 16 (17 Sep 2025)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-16-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:16</code></li> <li>Source code as   tar.gz   or zip</li> <li>Trino Helm chart <code>trino/trino-gateway</code> version <code>1.16.0</code></li> </ul> <p>Changes:</p> <p>General</p> <ul> <li> Breaking change: Require Java 24 to run Trino Gateway   and use it in the container image.   (#727)</li> <li>Update database testing and therefore support to PostgreSQL version 17.   (#753)</li> <li>Allow configuration of a default routing group and error propagation to client   tools. (#687)</li> <li>Add an option to add the <code>X-Forwarded-Proto</code> HTTP header when fetching cluster   stats to enable Trino Gateway use with clusters behind a TLS-terminations load   balancer.   (#729)  </li> <li>Improve error propagation when using an external routing service.   (#687)</li> <li>Add support for HTTP header modifications by an external routing service.   (#646)</li> <li>Add cluster activation status metric and emit to <code>/v1/jmx</code>.   (#673)</li> <li>Improve properties handling for JDBC connection to the database.   (#651)</li> <li> Breaking change: Rename the task delay configuration   for the monitor from <code>taskDelaySeconds</code> to <code>taskDelay</code> and to support Airlift   duration string instead of second values only.   (#695)</li> </ul> <p>UI</p> <ul> <li>Display routing group name in the query history page.   (#607)</li> <li>Rename <code>RoutedTo</code> to <code>Name</code> field in query history page.   (#639)</li> <li>Use external URL for query routing history display.   (#693)</li> <li>Add separate window for query text in query history page and enable display of   the full query text.    (#740)</li> <li>Show counts for healthy and unhealthy clusters in the summary section of the    dashboard page.   (#758)</li> <li>A column sorting to the clusters list on the dashboard page and column sorting   and filtering to the query list on the query history page.   (#752)</li> <li>Fix UI rendering issues on routing rules page.   (#660)</li> <li>Fix bug for non-admin users seeing login errors when accessing the UI when   page restrictions are configured.   (#664)</li> </ul> <p>More details and a list of all merged pull requests are available in the milestone 16 list.</p>"},{"location":"release-notes/#15","title":"Trino Gateway 15 (12 Mar 2025)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-15-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:15</code></li> <li>Source code as   tar.gz   or zip</li> <li>Trino Helm chart <code>trino/trino-gateway</code> version <code>1.15.0</code></li> </ul> <p>Changes:</p> <ul> <li>Add pop up messages for operations in the user interface.   (#617)</li> <li>Add support for configuring custom OpenMetrics from the Trino clusters for the   metrics monitor health check.   (#621)</li> <li> Breaking change: Change paths and file names in the   Docker image. Configuration file name is <code>/opt/trino-gateway/config.yaml</code> and    folder names use <code>trino-gateway</code> consistently.   (#623) and    (#628)</li> <li>Prevent proxy failures resulting from backend URL configuration containing a    trailing slash.   (#564)</li> <li>Fix query errors when adhoc routing group has no healthy backends.   (#630) and   (#641)</li> </ul> <p>More details and a list of all merged pull requests are available in the milestone 15 list.</p>"},{"location":"release-notes/#14","title":"Trino Gateway 14 (14 Feb 2025)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-14-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:14</code></li> <li>Source code as   tar.gz   or zip</li> <li>Trino Helm chart <code>trino/trino-gateway</code> version <code>1.14.0</code></li> </ul> <p>Changes:</p> <ul> <li>Add display of the cluster health status on the cluster page.   (#601)</li> <li>Add user interface page to show and edit routing rules.   (#433)</li> <li>Add support for automatic database schema validation and    upgrade during Trino Gateway startup.   (#575)</li> <li>Enable use of Oracle as backend database for Trino Gateway.   (#588)</li> <li>Add support to configure HTTP client options for the external routing group   selector. (#580)</li> <li>Add a cluster monitor using JMX data from Trino.   (#472)</li> <li>Add a cluster monitor using the Trino OpenMetrics endpoint with customizable   health definition. (#584)</li> <li>Add API health endpoints at <code>/trino-gateway/livez</code> and <code>/trino-gateway/readyz</code>   for monitoring liveness and readiness.   (#595)</li> <li> Breaking change: Change configuration file name from    <code>gateway-ha-config.yml</code> to <code>config.yaml</code>.   (#598)</li> <li> Breaking change: Load fundamental modules by default,    and remove  the related configurations <code>HaGatewayProviderModule</code>,    <code>ActiveClusterMonitor</code>, <code>ClusterStateListenerModule</code>, and    <code>ClusterStatsMonitorModule</code> from the configuration file.    (#597)</li> <li> Breaking change: Remove support for composite rules and   the use of easy-rules syntax.   (#540)</li> <li>Improve performance of Trino cluster stats collection and add a timeout   configuration. (#583)</li> <li>Fix visibility of chart legend text when changing the theme of the user   interface. (#585)</li> </ul> <p>More details and a list of all merged pull requests are available in the milestone 14 list.</p>"},{"location":"release-notes/#13","title":"Trino Gateway 13 (3 Dec 2024)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-13-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:13</code></li> <li>Source code as   tar.gz   or zip</li> <li>Trino Helm chart <code>trino/trino-gateway</code> version <code>1.13.0</code></li> </ul> <p>Changes:</p> <ul> <li>Allow proxying of HTTP PUT requests to Trino clusters.   (#543)</li> <li>Add a filter for <code>source</code> to the History page in the UI.   (#551)</li> <li>Log out inactive users from the UI automatically.   (#544)</li> </ul> <p>More details and a list of all merged pull requests are available in the milestone 13 list.</p>"},{"location":"release-notes/#2024","title":"2024","text":""},{"location":"release-notes/#12","title":"Trino Gateway 12 (7 Nov 2024)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-12-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:12</code></li> <li>Source code as   tar.gz   or zip</li> <li>Trino Helm chart <code>trino/trino-gateway</code> version <code>0.12.0</code></li> </ul> <p>Changes:</p> <ul> <li>Add support for parsing <code>EXECUTE IMMEDIATE</code> statements for routing.   (#484)</li> <li>Add support to set configuration values from environment variables.   (#483)</li> <li>Add support to include information about the cluster used for query processing   to the response cookie.   (#465)</li> <li>Add support for configuring the startup command for Trino Gateway in the   Helm chart with the <code>command</code> node.   (#505)</li> <li> Breaking change: Require Java 23 for build and    runtime. Use Java 23 as runtime in the container.   (#486)</li> <li> Breaking change: Rename routing rule configuration   <code>blackListHeaders</code> to<code>excludeHeaders</code>.   (#470)</li> <li>Prevent request analyzer failures for some queries without a defined catalog.   (#478)</li> <li>Fix parsing failure and therefore routing problems for queries using <code>WITH</code>    clauses.   (#528)</li> </ul> <p>More details and a list of all merged pull requests are available in the milestone 12 list.</p>"},{"location":"release-notes/#11","title":"Trino Gateway 11 (12 Sep 2024)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-11-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:11</code></li> <li>Source code as   tar.gz   or zip</li> <li>Helm chart <code>11.0.0</code> in <code>helm/trino-gateway</code> of the tagged source code</li> </ul> <p>Changes:</p> <ul> <li> Breaking change: Require Java 22 for build and runtime.   (#441)</li> <li>Add support for determining routing group in an external service.   (#423)</li> <li>Add an option to forward requests without adding <code>X-Forwarded-*</code> HTTP headers   with the <code>addXForwardedHeaders: false</code> configuration in <code>routing</code>.   (#417)</li> <li>Add OpenMetrics endpoint to   enable monitoring with Prometheus and compatible systems.   (#429)</li> <li>Add option to deactivate hostname verification for the certificate    of the Trino clusters.   (#436)</li> <li>Add option to use additional paths as Trino client REST API endpoints.   (#326)</li> <li>Add timeout parameters for INFO_API and JDBC health checks.   (#424)</li> <li>Add support for specifying custom labels in the Helm chart <code>commonLabels</code>.   (#448)</li> <li>Enable routing for requests to kill query processing.   (#427)</li> <li>Fix routing functionality and query history issues caused by lowercase    HTTP headers in HTTP/2 connections.   (#450)</li> <li>Fix failures when clients use HTTP/2.   (#451)</li> <li>Ensure that the user history dashboard displays the correct user name.   (#370)</li> <li>Fix incorrect routing of OAuth logout requests.   (#455)</li> </ul> <p>More details and a list of all merged pull requests are available in the  milestone 11 list.</p>"},{"location":"release-notes/#10","title":"Trino Gateway 10 (24 Jul 2024)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-10-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:10</code></li> <li>Source code as   tar.gz   or zip</li> <li>Helm chart <code>10.0.0</code> in <code>helm/trino-gateway</code> of the tagged source code</li> </ul> <p>Changes:</p> <ul> <li> Breaking change: Remove support for Dropwizard and   Jetty Proxy integration and usage. Add   Airlift as the base application   framework as   used in Trino. This changes the supported Trino Gateway startup, configuration   files, and relevant properties. Find details in the   documentation, and specifically refer to the   upgrade guide when migrating from older releases.   (#41)</li> <li> Breaking change: Improve Helm chart reliability and   adjust to new Airlift base framework.   (#401)</li> <li>Enable routing rules to use query and user details extracted from the HTTP   request.   (#325)</li> <li>Add support for using an OIDC claim for authorization.   (#322)</li> <li>Improve OIDC spec compliance, and add state and nonce verification.   (#348)</li> <li>Allow null values for <code>userName</code> and <code>source</code> in the query history.   (#381)</li> <li>Show times in query distribution graph in UI in local time instead of UTC.   (#369)</li> <li>Fix problems with secrets, liveness, and readiness templates in Helm chart.   (#348)</li> <li>Fix cluster reordering issue in the cluster user interface.   (#331)</li> <li>Fix creation of new resource groups.   (#379)</li> </ul>"},{"location":"release-notes/#9","title":"Trino Gateway 9 (8 May 2024)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-9-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:9</code></li> <li>Source code as   tar.gz   or zip</li> </ul> <p>Changes:</p> <ul> <li>Ensure inclusion of UI in JAR and container artifacts. (#337)</li> </ul>"},{"location":"release-notes/#8","title":"Trino Gateway 8 (6 May 2024)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-8-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:8</code></li> <li>Source code as   tar.gz   or zip</li> </ul> <p>Changes:</p> <ul> <li>Add support for configurable router policies. (#98)</li> <li>Add a router policy based on query count per cluster. (#98)</li> <li>Add a router policy for select paths based on cookie content. (#188)</li> <li>Support configuring access permissions for UI pages. (#296)</li> <li>Add Helm chart for Kubernetes deployments. (#87)</li> <li>Require Java 21 for build and runtime. (#225)</li> <li>Fix the <code>userInfo</code> resource to pass role information used by the API, so that   the webapp authentication matches the API authentication. (#310)</li> </ul>"},{"location":"release-notes/#7","title":"Trino Gateway 7 (21 Mar 2024)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-7-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:7</code></li> <li>Source code as   tar.gz   or zip</li> </ul> <p>Changes:</p> <ul> <li>Replace user interface with a new modern UI. (#116)</li> <li>Improve logging configurability. Users must update to the    new logging configuration. (#260)</li> <li>Improve Trino cluster health check performance and remove authentication requirement    by using the <code>v1/info</code> endpoint. (#264)</li> <li>Fix query id tracking based on request querystring parsing. (#265)</li> </ul> <p>Details about all pull requests and issues</p>"},{"location":"release-notes/#6","title":"Trino Gateway 6 (16 Feb 2024)","text":"<p>Artifacts:</p> <ul> <li>JAR file gateway-ha-6-jar-with-dependencies.jar</li> <li>Container image <code>trinodb/trino-gateway:6</code></li> <li>Source code as   tar.gz   or zip</li> </ul> <p>Changes:</p> <ul> <li>Add Docker container build, publishing, and usage setup and instructions. (#86)</li> </ul> <p>Details about all pull requests and issues</p>"},{"location":"release-notes/#5","title":"Trino Gateway 5 (24 Jan 2024)","text":"<p>Artifacts:</p> <ul> <li>gateway-ha-5-jar-with-dependencies.jar</li> <li>Source code as   tar.gz   or zip</li> </ul> <p>Changes:</p> <ul> <li>Add support for OAuth 2 audience use. (#164)</li> <li>Add quickstart scripts and documentation. (#110)</li> <li>Add project logo. (#111)</li> <li>Prevent ignoring HTTP header configuration. (#100)</li> </ul> <p>Details about all merged pull requests</p>"},{"location":"release-notes/#4","title":"Trino Gateway 4 (30 Nov 2023)","text":"<p>Artifacts:</p> <ul> <li>gateway-ha-4-jar-with-dependencies.jar</li> <li>Source code as   tar.gz   or zip</li> </ul> <p>Changes:</p> <ul> <li>Add support for configuring additional whitelisted URL paths. (#63)</li> <li>Improve flexibility of user and group name matching for authorization. (#32)</li> <li>Add support to use external URL for backend creation. (#76)</li> <li>Enable configuration of HTTP header size. (#67)</li> <li>Automatically set JDBC configuration parameter for TLS when connecting to   clusters for monitoring. (#71)</li> <li>Modernize application and remove potential for undiscovered bugs and security   issues with update of many core dependencies. (#59)</li> <li>Avoid failure when unhandled OIDC properties are present. (#69)</li> <li>Prevent failures resulting from reloading and parsing rules file. (#5)</li> </ul> <p>Details about all merged pull requests</p>"},{"location":"release-notes/#2023","title":"2023","text":""},{"location":"release-notes/#3","title":"Trino Gateway 3 (26 Sep 2023)","text":"<p>Artifacts:</p> <ul> <li>gateway-ha-3-jar-with-dependencies.jar</li> <li>Source code as   tar.gz   or zip</li> </ul> <p>Changes:</p> <p>The first release of Trino Gateway is based on the  Presto Gateway 1.9.5 codebase (#4) with these additions:</p> <ul> <li>Add authentication and authorization with LDAP, OIDC and user list from config   file. (#9)</li> <li>Add support for user, admin and API roles. (#9)</li> <li>Add healthcheck for Trino backends using JDBC. (#9)</li> <li>Add TCP check for routing. (#9)</li> <li>Add logic to route requests only to healthy backends. (#13)</li> <li>Add PostgreSQL support for backend database. (#13)</li> <li>Allow routing of <code>/v1/node</code> endpoint URL. (#27)</li> <li>Filter logs for sensitive information. (#9)</li> <li>Require Java 17 for build and runtime. (#16)</li> <li>Deactivate clusters with zero workers. (#13)</li> <li>Remove concurrency issue from repeated rules file loading. (#9)</li> </ul> <p>Details about all merged pull requests</p>"},{"location":"release-notes/#breaking-changes","title":"Breaking changes  <p>Starting with Trino Gateway 10, release note entries include a  Breaking change: prefix to highlight any changes as potentially  breaking changes. The following changes are considered and may require adjustments:</p> <ul> <li>Removal or renaming of configuration properties that may prevent startup or    require configuration changes.</li> <li>Changes to default values for configuration properties that may significantly   change the behavior of a system.</li> <li>Updates to the requirements for external systems or software used with    Trino Gateway.</li> <li>Non-backwards compatible changes which may require router modules to    be updated.</li> <li>Otherwise significant changes that requires specific attention from teams    managing a Trino Gateway deployment.</li> </ul>","text":""},{"location":"resource-groups-api/","title":"Resource groups API","text":"<p>Trino Gateway facilitates the management of resource groups across multiple Trino clusters, using the database resource group manager. It allows users to connect their Trino clusters to a centralized resource groups table maintained in the Trino Gateway's database. This setup enables management of resource groups either through the API or the Trino Gateway user interface.</p> <p>Trino offers both file-based and database resource group management. Using Trino Gateway with database management avoids the need for cluster re-deployments when updating resource groups, enhancing operational efficiency.</p> <p>For resource group and selector apis, we can now specify a query parameter with the request supporting multiple trino databases for different trino backends. This allows a user to configure a db for every trino backend with their own resource groups and selector tables. To use this, just specify the query parameter ?useSchema= to the request. Example, to list all resource groups, <pre><code>curl -X GET http://localhost:8080/trino/resourcegroup/read/{INSERT_ID_HERE}?useSchema=newdatabasename\n</code></pre>"},{"location":"resource-groups-api/#add-a-resource-group","title":"Add a resource group","text":"<p>To add a single resource group, specify all relevant fields in the body. Resource group id should not be specified since the database should autoincrement it.</p> <pre><code>curl -X POST http://localhost:8080/trino/resourcegroup/create \\\n -d '{\n        \"name\": \"resourcegroup1\", \\\n        \"softMemoryLimit\": \"100%\", \\\n        \"maxQueued\": 100, \\\n        \"softConcurrencyLimit\": 100, \\\n        \"hardConcurrencyLimit\": 100, \\\n        \"schedulingPolicy\": null, \\\n        \"schedulingWeight\": null, \\\n        \"jmxExport\": null, \\\n        \"softCpuLimit\": null, \\\n        \"hardCpuLimit\": null, \\\n        \"parent\": null, \\\n        \"environment\": \"test\" \\\n    }'\n</code></pre>"},{"location":"resource-groups-api/#get-existing-resource-groups","title":"Get existing resource group(s)","text":"<p>If no resourceGroupId (type long) is specified, then all existing resource groups are fetched.</p> <pre><code>curl -X GET http://localhost:8080/trino/resourcegroup/read/{INSERT_ID_HERE}\n</code></pre>"},{"location":"resource-groups-api/#update-a-resource-group","title":"Update a resource group","text":"<p>Specify all columns in the body, which will overwrite properties for the resource group with that specific resourceGroupId.</p> <pre><code>curl -X POST http://localhost:8080/trino/resourcegroup/update \\\n -d '{  \"resourceGroupId\": 1, \\\n        \"name\": \"resourcegroup_updated\", \\\n        \"softMemoryLimit\": \"80%\", \\\n        \"maxQueued\": 50, \\\n        \"softConcurrencyLimit\": 40, \\\n        \"hardConcurrencyLimit\": 60, \\\n        \"schedulingPolicy\": null, \\\n        \"schedulingWeight\": null, \\\n        \"jmxExport\": null, \\\n        \"softCpuLimit\": null, \\\n        \"hardCpuLimit\": null, \\\n        \"parent\": null, \\\n        \"environment\": \"test\" \\\n    }'\n</code></pre>"},{"location":"resource-groups-api/#delete-a-resource-group","title":"Delete a resource group","text":"<p>To delete a resource group, specify the corresponding resourceGroupId (type long).</p> <pre><code>curl -X POST http://localhost:8080/trino/resourcegroup/delete/{INSERT_ID_HERE}\n</code></pre>"},{"location":"resource-groups-api/#add-a-selector","title":"Add a selector","text":"<p>To add a single selector, specify all relevant fields in the body. Resource group id should not be specified since the database should autoincrement it.</p> <pre><code>curl -X POST http://localhost:8080/trino/selector/create \\\n -d '{\n        \"priority\": 1, \\\n        \"userRegex\": \"selector1\", \\\n        \"sourceRegex\": \"resourcegroup1\", \\\n        \"queryType\": \"insert\" \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#get-existing-selectorss","title":"Get existing selectors(s)","text":"<p>If no resourceGroupId (type long) is specified, then all existing selectors are fetched.</p> <pre><code>curl -X GET http://localhost:8080/trino/selector/read/{INSERT_ID_HERE}\n</code></pre>"},{"location":"resource-groups-api/#update-a-selector","title":"Update a selector","text":"<p>To update a selector, the existing selector must be specified with all relevant fields under \"current\". The updated version of that selector is specified under \"update\", with all relevant fields included. If the selector under \"current\" does not exist, a new selector will be created with the details under \"update\". Both \"current\" and \"update\" must be included to update a selector.</p> <pre><code>curl -X POST http://localhost:8080/trino/selector/update \\\n -d '{  \"current\": {\n            \"resourceGroupId\": 1, \\\n            \"priority\": 1, \\\n            \"userRegex\": \"selector1\", \\\n            \"sourceRegex\": \"resourcegroup1\", \\\n            \"queryType\": \"insert\" \\\n        },\n        \"update\":  {\n            \"resourceGroupId\": 1, \\\n            \"priority\": 2, \\\n            \"userRegex\": \"selector1_updated\", \\\n            \"sourceRegex\": \"resourcegroup1\", \\\n            \"queryType\": null \\\n        }\n}'\n</code></pre>"},{"location":"resource-groups-api/#delete-a-selector","title":"Delete a selector","text":"<p>To delete a selector, specify all relevant fields in the body.</p> <pre><code>curl -X POST http://localhost:8080/trino/selector/delete \\\n -d '{  \"resourceGroupId\": 1, \\\n        \"priority\": 2, \\\n        \"userRegex\": \"selector1_updated\", \\\n        \"sourceRegex\": \"resourcegroup1\", \\\n        \"queryType\": null \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#add-a-global-property","title":"Add a global property","text":"<p>To add a single global property, specify all relevant fields in the body.</p> <pre><code>curl -X POST http://localhost:8080/trino/globalproperty/create \\\n -d '{\n        \"name\": \"cpu_quota_period\", \\\n        \"value\": \"1h\" \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#get-existing-global-properties","title":"Get existing global properties","text":"<p>If no name (type String) is specified, then all existing global properties are fetched.</p> <pre><code>curl -X GET http://localhost:8080/trino/globalproperty/read/{INSERT_NAME_HERE}\n</code></pre>"},{"location":"resource-groups-api/#update-a-global-property","title":"Update a global property","text":"<p>Specify all columns in the body, which will overwrite properties for the global property with that specific name.</p> <pre><code>curl -X POST http://localhost:8080/trino/globalproperty/update \\\n -d '{\n        \"name\": \"cpu_quota_period\", \\\n        \"value\": \"2h\" \\\n     }'\n</code></pre>"},{"location":"resource-groups-api/#delete-a-global-property","title":"Delete a global property","text":"<p>To delete a global property, specify the corresponding name (type String).</p> <pre><code>curl -X POST http://localhost:8080/trino/globalproperty/delete/{INSERT_NAME_HERE}\n</code></pre>"},{"location":"resources/","title":"Resources","text":"<p>The following list contains public information about Trino Gateway such as blog posts, presentations, or available videos. Information about organizations using Trino Gateway is available on the users page. </p> <p>Newest entries are on top of the list.</p>"},{"location":"resources/#opening-up-the-trino-gateway","title":"Opening up the Trino Gateway","text":"<p>A project update presented by Manfred Moser, Will Morrison, Vishal Jadhav, and Jaehoo Yoo at Trino Summit in December 2024.</p> <p> Video recording | Slide deck</p>"},{"location":"resources/#trino-gateway-because-one-trino-cluster-is-not-enough","title":"Trino Gateway - because one Trino cluster is not enough","text":"<p>An overview for wider audience presented by Will Morrison and Manfred Moser at  Open Source Data Summit in October 2024.</p> <p> Video recording | Slide deck</p>"},{"location":"resources/#many-clusters-and-only-one-gateway","title":"Many clusters and only one gateway","text":"<p>Project announcement and overview at Trino Summit 2023 with use cases from Bloomberg and Naver.</p> <p> Video recording | Slide deck</p>"},{"location":"resources/#older-resources","title":"Older resources","text":"<ul> <li>Slide deck about Trino Gateway status   for Trino Contributor Congregation in June 2024</li> <li>Trino Gateway announcement blog post</li> </ul>"},{"location":"routers/","title":"Routers","text":"<p>Trino Gateway offers two entry-level router options, providing users with a  straightforward and easy-to-use starting point for their routing needs. The  routers make the decision based on the clusters load reported in ClusterStats.</p>"},{"location":"routers/#stochasticroutingmanager","title":"StochasticRoutingManager","text":"<p>This primary routing mechanism employs a straightforward, decentralized  approach, dispatching incoming queries in a random manner without utilizing  advanced optimization techniques.</p>"},{"location":"routers/#querycountbasedrouterprovider","title":"QueryCountBasedRouterProvider","text":"<p>This routing mechanism utilizes near real-time, user-level cluster load statistics. It uses running queries count and query queue lengths to determine the most suitable cluster for each individual user. With is information it  directs queries to the least loaded cluster for that user, optimizing the  likelihood of successful execution.</p>"},{"location":"routers/#adding-a-routing-mechanism","title":"Adding a routing mechanism","text":"<p>To enhance Trino Gateway's capabilities, you can create and contribute new and advanced router modules with intelligent routing features. To integrate a new router, you need to create a provider module that can be configured via the  configuration file. This allows for seamless addition of new routers without disrupting existing functionality.</p>"},{"location":"routers/#add-router-provider-module","title":"Add router Provider module","text":"<p>Use the following steps to incorporate a new routing mechanism with advanced capabilities:</p> <ul> <li>Derive a class from <code>RouterBaseModule</code></li> <li>The module must instantiate the router and hold a reference to it.</li> <li>Add the module name to the <code>modules</code> section of the configuration file to load    the provider module and make the new router available.</li> <li>For example, <code>QueryCountBasedRouterProvider</code> and refer to the config file in    the following sections.</li> </ul>"},{"location":"routers/#add-router-class","title":"Add router class","text":"<p>Use the following steps to create a new router:</p> <ul> <li>Derive a class from <code>StochasticRoutingManager</code> to create the router that    does the actual work.</li> <li>Override the methods <code>provideAdhocBackend</code> and <code>provideBackendForRoutingGroup</code>   and implement the new smarter logic</li> <li>The router listens to the list of <code>ClusterStats</code> via the<code>updateBackEndStats</code>   method.</li> <li>This method is called on regular intervals defined in the config    parameter <code>monitor=&gt;taskDelay</code>.</li> <li>Each element in the list corresponds to each backend cluster.</li> <li>Only the stats from the healthy cluster are reported, unhealthy clusters are   not included in the list. If you have three cluster backends and one is   unhealthy, then the parameter <code>List&lt;ClusterStats&gt; stats</code> has only two   elements.</li> <li>To get the cluster stats set the parameter   <code>clusterStatsConfiguration=&gt;monitorType</code> to <code>UI_API</code> or <code>JDBC</code> which in turn   needs the setup of <code>backendState</code> section in the config file.</li> </ul>"},{"location":"routers/#configuration-file-reference","title":"Configuration file reference","text":"<pre><code>backendState:\n  username: &lt;usernme&gt;\n  password: &lt;password&gt;\n  ssl: &lt;false/true&gt;\n  xForwardedProtoHeader: &lt;false/true&gt;\n\nclusterStatsConfiguration:\n  monitorType: UI_API\n\nmodules:\n  - io.trino.gateway.ha.module.QueryCountBasedRouterProvider\n</code></pre>"},{"location":"routing-logic/","title":"Routing Logic","text":""},{"location":"routing-logic/#overview","title":"Overview","text":"<p>Trino Gateway checks incoming requests to see if they're related to previous  ones it handled. If they are, then Trino Gateway sends them to the same  Trino cluster that dealt with the earlier requests.</p> <p>If it is a new request, the Trino Gateway refers to Routing rules  to decide which group of clusters, called a 'Routing Group,' should handle it.  It then picks a cluster from that Routing Group to handle the request using  either an adaptive or round-robin strategy.</p> <p></p>"},{"location":"routing-logic/#sticky-routing","title":"Sticky routing","text":"<p>A request related to an ongoing process, or to state maintained on a single  Trino cluster, must be routed to that cluster for proper handling. Two  mechanisms for identifying related requests are currently implemented. By default, only routing based on query identifier is enabled.</p>"},{"location":"routing-logic/#routing-based-on-query-identifier-default","title":"Routing based on query identifier (default)","text":"<p>When a query is initiated through the Trino Gateway, the query id will be  extracted from the response and mapped to the cluster that provided the  response. Any subsequent request containing that query id will be forwarded  to that cluster. For example, to retrieve query results, the Trino client  polls a URI of the form  <code>v1/statement/executing/queryid/nonce/counter</code>. The Trino Gateway will extract the queryid from this URI.</p>"},{"location":"routing-logic/#routing-based-on-cookies","title":"Routing based on cookies","text":"<p>OAuth2 authentication requires that the same cluster is used for each step of  the handshake. When <code>gatewayCookieConfiguration.enabled</code> is set to true, a cookie  will be added to requests made to paths beginning with <code>/oauth2</code> unless they already have  a cookie present, which is used to route further <code>/oauth2/*</code> requests to the correct cluster.  Cookies are not added to requests to <code>v1/*</code> and other Trino endpoints.</p> <p>Trino Gateway signs its cookies to ensure that they are not tampered with. You  must set a <code>cookieSigningSecret</code> string in your configuration <pre><code>gatewayCookieConfiguration:\n    enabled: true\n    cookieSigningSecret: \"ahighentropystring\"\n</code></pre> when making use of this feature. If you load balance request across multiple Trino Gateway instances, ensure each instance has the same <code>cookieSigningSecret</code>.</p> <p>The Trino Gateway handles standard Trino OAuth2 handshakes with no additional  configuration. If you are using a customized or commercial Trino distribution, then the paths used to define the OAuth handshake may be modified.</p> <p><code>routingPaths</code>: If the request URI starts with a path in this list, then</p> <ul> <li>If no cookie is present, add a routing cookie</li> <li>If a cookie is present, route the request to the cluster defined by that cookie</li> </ul> <p><code>deletePaths</code>: If the request URI starts with a path in this list, return a response that instructs the client to delete the cookie.</p> <p>Additionally, the <code>lifetime</code> property sets the duration for which a cookie remains in  effect after creation. Ensure that it is greater than the time required to complete the handshake. Default <code>lifetime</code> is 10 minutes.</p> <p>These properties are defined under the <code>oauth2GatewayCookieConfiguration</code> node: </p> <pre><code>oauth2GatewayCookieConfiguration:\n  routingPaths:\n    - \"/oauth2\"\n    - \"/custom/oauth2/callback\"\n    - \"/alternative/oauth2/initiate\"\n  deletePaths:\n    - \"/custom/logout\"\n  lifetime: \"5m\"\n</code></pre>"},{"location":"routing-logic/#routing-urls","title":"Routing URLs","text":"<p>Each Trino cluster configured with the Trino Gateway includes both a <code>proxyTo</code>  URL and an <code>externalURL</code>. The <code>proxyTo</code> URL is used internally by the Trino  Gateway to route requests based on routing rules and query identifiers, whereas  the <code>externalURL</code> serves as a UI-accessible or publicly reachable address for  the Trino cluster, and is commonly used to access Trino web UI </p> <p>For example, in a Kubernetes environment, the <code>proxyTo</code> URL might be  <code>trino-backend-service.trino-namespace.svc.cluster.local:8083</code> for communication  between the Trino Gateway and Trino clusters, and the external URL for the same  backend cluster might be <code>trino.domain.com</code>.</p>"},{"location":"routing-rules/","title":"Routing rules","text":"<p>Trino Gateway includes a routing rules engine.</p> <p>By default, Trino Gateway reads the <code>X-Trino-Routing-Group</code> request header to route requests. Use the <code>defaultRoutingGroup</code> setting to specify a fallback group,  defaults to the <code>adhoc</code> group.</p> <pre><code>routing:\n    defaultRoutingGroup: \"test-group\"\n</code></pre> <p>The routing rules engine feature enables you to either write custom logic to route requests based on the request info such as any of the request headers, or set a URL address to make an HTTP POST request and route based on the returned result.</p> <p>Routing rules are defined in a configuration file or implemented in separate, custom service application. The connection to the separate service is configured as a URL. It can implement any dynamic rule changes or other behavior.</p>"},{"location":"routing-rules/#enabling-the-routing-rules-engine","title":"Enabling the routing rules engine","text":"<p>To enable the routing rules engine, find the following lines in <code>config.yaml</code>:</p> <ul> <li>Set <code>rulesEngineEnabled</code> to <code>true</code>, then <code>rulesType</code> as <code>FILE</code> or <code>EXTERNAL</code>.</li> <li>If you set <code>rulesType: FILE</code>, then set <code>rulesConfigPath</code> to the path to your   rules config file.</li> <li>The rules file will be re-read every minute by default. You may change this by setting   <code>rulesRefreshPeriod: Duration</code>, where duration is an airlift style Duration such as <code>30s</code>.</li> <li>If you set <code>rulesType: EXTERNAL</code>, set <code>rulesExternalConfiguration</code> to the URL   of an external service for routing rules processing.</li> <li><code>rulesType</code> is by default <code>FILE</code> unless specified.</li> </ul> <pre><code>routingRules:\n    rulesEngineEnabled: true\n    rulesType: FILE\n    rulesConfigPath: \"app/config/routing_rules.yml\" # replace with actual path to your rules config file\n    rulesExternalConfiguration:\n        urlPath: https://router.example.com/gateway-rules # replace with your own API path\n        excludeHeaders:\n            - 'Authorization'\n            - 'Accept-Encoding'\n        propagateErrors: false\n</code></pre> <ul> <li>Redirect URLs are not supported.</li> <li>Optionally, add headers to the <code>excludeHeaders</code> list to exclude requests with   corresponding header values from being sent in the POST request.</li> <li>Check headers to exclude when making API requests, specifics depend on the   network configuration.</li> <li>Set <code>propagateErrors</code> to <code>true</code> to forward routing service errors to   clients if present in the response.</li> </ul> <p>If there is error parsing the routing rules configuration file, an error is logged, and requests are routed using the routing group header <code>X-Trino-Routing-Group</code> as default.</p>"},{"location":"routing-rules/#configuring-api-requests-with-http-client-config","title":"Configuring API requests with HTTP client config","text":"<p>You can configure the HTTP client by adding the following configuration to the <code>serverConfig:</code> section with the <code>router</code> prefix.</p> <pre><code>serverConfig:\n    router.http-client.request-timeout: 1s\n</code></pre> <p>Please refer to the Trino HTTP client properties documentation for more.</p>"},{"location":"routing-rules/#use-an-external-service-for-routing-rules","title":"Use an external service for routing rules","text":"<p>You can use an external service for processing your routing by setting the <code>rulesType</code> to <code>EXTERNAL</code> and configuring the <code>rulesExternalConfiguration</code>.</p> <p>Trino Gateway then sends all headers, other than those specified in <code>excludeHeaders</code>, as a map in the body of a POST request to the external service. If <code>requestAnalyzerConfig.analyzeRequest</code> is set to <code>true</code>, <code>TrinoRequestUser</code> and <code>TrinoQueryProperties</code> are also included.</p> <p>Additionally, the following HTTP information is included:</p> <ul> <li><code>remoteUser</code></li> <li><code>method</code></li> <li><code>requestURI</code></li> <li><code>queryString</code></li> <li><code>session</code></li> <li><code>remoteAddr</code></li> <li><code>remoteHost</code></li> <li><code>parameterMap</code></li> </ul> <p>The external service can process the information in any way desired and must return a result with the following criteria:</p> <ul> <li>Response status code of OK (200)</li> <li>Message in JSON format</li> <li>Only one group can be returned</li> <li>If <code>errors</code> is not null, the query is routed to the configured default group</li> </ul>"},{"location":"routing-rules/#request-headers-modification","title":"Request headers modification","text":"<p>The external routing service can optionally return an <code>externalHeaders</code> map in its response to add or modify HTTP headers before the request is forwarded.</p> <p>This enables dynamic customization of request behavior, such as injecting session properties or setting client tags before the request reaches the Trino cluster.</p> <pre><code>{\n    \"routingGroup\": \"test-group\",\n    \"errors\": [\n        \"Error1\",\n        \"Error2\",\n        \"Error3\"\n    ],\n    \"externalHeaders\": {\n        \"x-trino-client-tags\": \"['etl']\",\n        \"x-trino-session\": \"query_max_memory=50GB,optimize_metadata_queries=false\"\n    }\n}\n</code></pre>"},{"location":"routing-rules/#configure-routing-rules-with-a-file","title":"Configure routing rules with a file","text":"<p>Rules consist of a name, description, condition, and list of actions. If the condition of a particular rule evaluates to <code>true</code>, its actions are fired. Rules are stored as a  multi-document YAML file. </p> <pre><code>---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl\")'\n---\nname: \"airflow special\"\ndescription: \"if query from airflow with special label, route to etl-special group\"\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") contains \"label=special\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl-special\")'\n</code></pre> <p>Three objects are available by default. They are</p> <ul> <li><code>request</code>, the incoming request as an HttpServletRequest</li> <li><code>state</code>, a <code>HashMap&lt;String, Object&gt;</code> that allows passing arbitrary state from one rule evaluation to the next</li> <li><code>result</code>, a <code>HashMap&lt;String, String&gt;</code> that is used to return the result of rule evaluation to the engine</li> </ul> <p>In addition to the default objects, rules may optionally utilize trinoRequestUser and trinoQueryProperties , which provide information about the user and query respectively. You must include an action of the form <code>result.put(\\\"routingGroup\\\", \\\"foo\\\")</code> to trigger routing of a request that satisfies the condition to the specific routing group. Without this action, the configured default group is used and the whole routing rule is redundant.</p> <p>The condition and actions are written in MVEL, an expression language with Java-like syntax. Classes from <code>java.util</code>, data-type  classes from <code>java.lang</code> such as <code>Integer</code> and <code>String</code>, as well as <code>java.lang.Math</code> and <code>java.lang.StrictMath</code> are available in rules. Rules may not use <code>java.lang.System</code> and other classes that allow access the Java runtime and operating system. In most cases, you can write conditions and actions in Java syntax and expect it to work. One exception is  parametrized types. Exclude type parameters, for example to add a <code>HashSet</code> to the <code>state</code> variable, use an action such as: <pre><code>actions:\n  - |\n    state.put(\"triggeredRules\",new HashSet())\n</code></pre> This is equivalent to <code>new HashSet&lt;Object&gt;()</code>. </p> <p>There are some MVEL-specific operators. For example, instead of doing a null-check before accessing the <code>String.contains</code> method like this:</p> <pre><code>condition: 'request.getHeader(\"X-Trino-Client-Tags\") != null &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\").contains(\"label=foo\")'\n</code></pre> <p>You can use the <code>contains</code> operator</p> <pre><code>condition: 'request.getHeader(\"X-Trino-Client-Tags\") contains \"label=foo\"'\n</code></pre> <p>If no rules match, then the request is routed to the configured default routing group.</p>"},{"location":"routing-rules/#trinostatus","title":"TrinoStatus","text":"<p>The <code>TrinoStatus</code> class attempts to track the current state of the configured Trino clusters. The three possible states of these cluster are updated with every healthcheck:</p> <ul> <li><code>PENDING</code>: A Trino cluster shows this state when it is still starting up. It   is treated as unhealthy by <code>RoutingManager</code>, and therefore requests are   not be routed to these clusters.</li> <li><code>HEALTHY</code>: A Trino cluster shows this state when healthchecks report   the cluster as healthy and ready. <code>RoutingManager</code> only routes requests to   healthy clusters.</li> <li><code>UNHEALTHY</code>: A Trino cluster shows this state when healthchecks report the   cluster as unhealthy. <code>RoutingManager</code>  does not route requests to unhealthy   clusters.</li> </ul>"},{"location":"routing-rules/#trinorequestuser","title":"TrinoRequestUser","text":"<p>The  <code>TrinoRequestUser</code> class attempts to extract user information from a request, in the following order:</p> <ol> <li><code>X-Trino-User</code> header.</li> <li><code>Authorization: Basic</code> header.</li> <li><code>Authorization: Bearer</code> header. Requires configuring an OAuth2 User Info URL.</li> <li><code>Trino-UI-Token</code> or <code>__Secure-Trino-ID-Token</code> cookie.</li> </ol> <p>Kerberos and Certificate authentication are not currently supported. If the request contains the <code>Authorization: Bearer</code> header, an attempt is made to treat the token as a JWT and deserialize it. If this is successful, the value of the claim named in <code>requestAnalyzerConfig.tokenUserField</code> is used as the username. By default, this is the <code>email</code> claim. If the token is not a valid JWT, and <code>requestAnalyzerConfig.oauthTokenInfoUrl</code> is configured, then the token is exchanged with the Info URL. Responses are cached for 10 minutes to avoid triggering rate limits.</p> <p>You may call <code>trinoRequestUser.getUser()</code> and <code>trinoRequestUser.getUserInfo()</code> in your routing rules. If user information was not successfully extracted, <code>trinoRequestUser.getUser()</code> returns an empty <code>Optional</code>. <code>trinoRequestUser.getUserInfo()</code> returns an <code>Optional&lt;UserInfo&gt;</code>, with an OpenID Connect UserInfo if a token is successfully exchanged with the <code>oauthTokenInfoUrl</code>, and an empty <code>Optional</code> otherwise.</p> <p><code>trinoRequestUser.userExistsAndEquals(\"usernameToTest\")</code> can be used to check a username against the extracted user. It returns <code>false</code> if a user has not been extracted.</p> <p>User extraction is only available if enabled by configuring <code>requestAnalyzerConfig.analyzeRequest = True</code></p>"},{"location":"routing-rules/#trinoqueryproperties","title":"TrinoQueryProperties","text":"<p>The <code>TrinoQueryProperties</code> class attempts to parse the body of a request to determine the SQL statement and other information. Note that only a syntactic analysis is performed.</p> <p>If a query references a view, then that view is not expanded, and tables referenced by the view are not recognized. Views and materialized views are treated as tables and added to the list of tables in all contexts, including statements such as <code>CREATE VIEW</code>.</p> <p>A routing rule can call the following methods on the <code>trinoQueryProperties</code> object:</p> <ul> <li><code>String errorMessage()</code>: the error message, only if there was any error while   creating the <code>trinoQueryProperties</code> object.</li> <li><code>boolean isNewQuerySubmission()</code>: boolean flag to indicate if the   request is a POST to the <code>v1/statement</code> query endpoint.</li> <li><code>String getQueryType()</code>: the class name of the <code>Statement</code>, e.g. <code>ShowCreate</code>.   Note that these are not mapped to the <code>ResourceGroup</code> query types. For a full   list of potential query types, see the classes in   STATEMENT_QUERY_TYPES</li> <li><code>String getResourceGroupQueryType()</code>: the Resource Group query type, for   example <code>SELECT</code>, <code>DATA_DEFINITION</code>. For a full list see queryType in   the Trino documentation</li> <li><code>String getDefaultCatalog()</code>: the default catalog, if set. It may or may not   be referenced in the actual SQL</li> <li><code>String getDefaultSchema()</code>: the default schema, if set. It may or may not   be referenced in the actual SQL</li> <li><code>Set&lt;String&gt; getCatalogs()</code>: the set of catalogs used in the query. Includes   the default catalog if used by a non-fully qualified table reference</li> <li><code>Set&lt;String&gt; getSchemas()</code>: the set of schemas used in the query. Includes the   default schema if used by a non-fully qualified table reference</li> <li><code>Set&lt;String&gt; getCatalogSchemas()</code> the set of qualified schemas used in the   query, in the form <code>catalog.schema</code></li> <li><code>boolean tablesContains(String testName)</code> returns true if the query contains a   reference to the table <code>testName</code>.<code>testName</code> should be fully qualified, for   example <code>testcat.testschema.testtable</code></li> <li><code>Set&lt;QualifiedName&gt; getTables()</code>: the set of tables used in the query. These   are fully qualified, any partially qualified table reference in the SQL   will be qualified by the default catalog and schema.</li> <li><code>String getBody()</code>: the raw request body</li> </ul>"},{"location":"routing-rules/#configuration","title":"Configuration","text":"<p>The <code>trinoQueryProperties</code>  are configured under the <code>requestAnalyzerConfig</code> configuration node.</p> <p><code>analyzeRequest</code>:</p> <p>Set to <code>True</code> to make <code>trinoQueryProperties</code> and <code>trinoRequestUser</code> available.</p> <p><code>maxBodySize</code>:</p> <p>By default, the max body size is 1,000,000 characters. This can be modified by configuring <code>maxBodySize</code>. If the request body is greater or equal to this limit, Trino Gateway does not process the query. A buffer of length <code>maxBodySize</code> is allocated per query. Reduce this value if you observe excessive garbage collection at runtime. <code>maxBodySize</code> cannot be set to values larger than 2**31-1, the maximum size of a Java String.</p> <p><code>isClientsUseV2Format</code>:</p> <p>Some commercial extensions to Trino use the V2 Request Structure V2 style request structure. Support for V2-style requests can be enabled by setting this property to <code>true</code>. If you use a commercial version of Trino, ask your vendor how to set this configuration.</p> <p><code>tokenUserField</code>:</p> <p>When extracting the user from a JWT token, this field is used as the username. By default, the <code>email</code> claim is used.</p> <p><code>oauthTokenInfoUrl</code>:</p> <p>If configured, Trino Gateway attempts to retrieve the user info by exchanging potential authorization tokens with this URL. Responses are cached for 10 minutes to avoid triggering rate limits.</p>"},{"location":"routing-rules/#execution-of-rules","title":"Execution of rules","text":"<p>All rules whose conditions are satisfied fire. For example, in the \"airflow\" and \"airflow special\" example rules from the following rule priority section, a query with source <code>airflow</code> and label <code>special</code> satisfies both rules. The <code>routingGroup</code> is set to <code>etl</code> and then to <code>etl-special</code> because of the order in which the rules of defined. If you swap the order of the rules, then you get <code>etl</code> instead.</p> <p>You can avoid this ordering issue by writing atomic rules, so any query matches exactly one rule. For example you can change the first rule to the following:</p> <pre><code>---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") == null'\nactions:\n  - 'result.put(\"routingGroup\", \"etl\")'\n---\n</code></pre> <p>This can difficult to maintain with more rules. To have better control over the execution of rules, we can use rule priorities. Overall, priorities and other constructs that MVEL support allows you to express your routing logic.</p>"},{"location":"routing-rules/#rule-priority","title":"Rule priority","text":"<p>You can assign an integer value <code>priority</code> to a rule. The lower this integer is, the earlier it fires. If the priority is not specified, the priority defaults to <code>INT_MAX</code>. Following is an example with priorities:</p> <pre><code>---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\npriority: 0\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl\")'\n---\nname: \"airflow special\"\ndescription: \"if query from airflow with special label, route to etl-special group\"\npriority: 1\ncondition: 'request.getHeader(\"X-Trino-Source\") == \"airflow\" &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") contains \"label=special\"'\nactions:\n  - 'result.put(\"routingGroup\", \"etl-special\")'\n</code></pre> <p>Note that both rules still fire. The difference is that you are guaranteed that the first rule (priority 0) is fired before the second rule (priority 1). Thus <code>routingGroup</code> is set to <code>etl</code> and then to <code>etl-special</code>, so the <code>routingGroup</code> is always <code>etl-special</code> in the end.</p> <p>More specific rules must be set to a higher priority so they are evaluated last to set a <code>routingGroup</code>.</p>"},{"location":"routing-rules/#passing-state","title":"Passing State","text":"<p>The <code>state</code> object may be used to pass information from one rule evaluation to the next. This allows an author to avoid duplicating logic in multiple rules. Priority should be used to ensure that <code>state</code> is updated before being used  in downstream rules. For example, the atomic rules may be re-implemented as</p> <pre><code>---\nname: \"initialize state\"\ndescription: \"Add a set to the state map to track rules that have evaluated to true\"\npriority: 0\ncondition: \"true\"\nactions:\n  - |\n    state.put(\"triggeredRules\",new HashSet())\n  # MVEL does not support type parameters! HashSet&lt;String&gt;() would result in an error.\n---\nname: \"airflow\"\ndescription: \"if query from airflow, route to etl group\"\npriority: 1\ncondition: |\n  request.getHeader(\"X-Trino-Source\") == \"airflow\"\nactions:\n  - |\n    result.put(\"routingGroup\", \"etl\")\n  - |\n    state.get(\"triggeredRules\").add(\"airflow\")\n---\nname: \"airflow special\"\ndescription: \"if query from airflow with special label, route to etl-special group\"\npriority: 2\ncondition: |\n  state.get(\"triggeredRules\").contains(\"airflow\") &amp;&amp; request.getHeader(\"X-Trino-Client-Tags\") contains \"label=special\"\nactions:\n  - |\n    result.put(\"routingGroup\", \"etl-special\")\n</code></pre>"},{"location":"routing-rules/#if-statements-mvel-flow-control","title":"If statements (MVEL Flow Control)","text":"<p>You can use MVEL support for <code>if</code> statements and other flow control. The following logic in pseudocode:</p> <pre><code>if source == \"airflow\":\n  if clientTags[\"label\"] == \"foo\":\n    return \"etl-foo\"\n  else if clientTags[\"label\"] = \"bar\":\n    return \"etl-bar\"\n  else\n    return \"etl\"\n</code></pre> <p>This logic Can be implemented with the following rules:</p> <pre><code>---\nname: \"airflow rules\"\ndescription: \"if query from airflow\"\ncondition: \"request.getHeader(\\\"X-Trino-Source\\\") == \\\"airflow\\\"\"\nactions:\n  - \"if (request.getHeader(\\\"X-Trino-Client-Tags\\\") contains \\\"label=foo\\\") {\n      result.put(\\\"routingGroup\\\", \\\"etl-foo\\\")\n    }\n    else if (request.getHeader(\\\"X-Trino-Client-Tags\\\") contains \\\"label=bar\\\") {\n      result.put(\\\"routingGroup\\\", \\\"etl-bar\\\")\n    }\n    else {\n      result.put(\\\"routingGroup\\\", \\\"etl\\\")\n    }\"\n</code></pre>"},{"location":"security/","title":"Security","text":"<p>Trino Gateway has its own security with its own authentication and authorization. These features are used only to authenticate and authorize its user interface and the APIs. All Trino-related requests are passed through to the Trino cluster without any authentication or authorization check in Trino Gateway.</p>"},{"location":"security/#tls-configuration","title":"TLS configuration","text":"<p>All authentication and authorization mechanisms require configuring TLS as the foundational layer. Your site or cloud environment may already have a load balancer or proxy server configured and running with a valid, globally trusted TLS certificate. In this case, you can work with your network administrators to set up your Trino Gateway behind the load balancer.</p> <p>You can also configure an end-to-end TLS connection using Trino Gateway. This requires you to obtain and install a TLS certificate and configure Trino Gateway to use it for client connections. The following configuration enables TLS for Trino Gateway.</p> <pre><code>serverConfig:\n    http-server.http.enabled: false\n    http-server.https.enabled: true\n    http-server.https.port: 8443\n    http-server.https.keystore.path: certificate.pem\n    http-server.https.keystore.key: changeme\n</code></pre> <p>For advanced configurations, refer to the Trino TLS documentation for more details.</p>"},{"location":"security/#authentication","title":"Authentication","text":"<p>The authentication would happen on https protocol only. Add the <code>authentication:</code> section in the config file. The default authentication type is set using <code>defaultType: \"form\"</code> Following types of the authentications are supported.</p>"},{"location":"security/#oauthopenidconnect","title":"OAuth/OpenIDConnect","text":"<p>It can be configured as below</p> <pre><code>authentication:\n  defaultType: \"oauth\"\n  oauth:\n    issuer:\n    clientId:\n    clientSecret:\n    tokenEndpoint:\n    authorizationEndpoint:\n    jwkEndpoint:\n    redirectUrl:\n    redirectWebUrl: \n    userIdField:\n    scopes:\n      - s1\n      - s2\n      - s3\n</code></pre> <p>Set the <code>privilegesField</code> to retrieve privileges from an OAuth claim.</p>"},{"location":"security/#note","title":"Note","text":"<ul> <li>For OAuth Trino Gateway uses <code>oidc/callback</code> where as Trino uses <code>oauth2</code> path</li> <li>Trino Gateway should have its own client id</li> <li>All the Trino clusters should have a single client id.</li> <li>Trino Gateway needs to pass thorugh the Trino Oauth2 requests only to one of the clusters.</li> <li>One way to handle it is to set a special rule like below: <pre><code>  ---\n  name: \"Oauth requests\"\n  description: \"Oauth requests need to go to a single backed\"\n  condition: \"request.getRequestURI.startsWith(\\\"/oauth2\\\")\"\n  actions:\n    - \"result.put(\\\"routingGroup\\\", \\\"oauth2-handler\\\")\"\n</code></pre></li> <li>That also means you need to have a cluster with that routing group.</li> <li>It's ok to replicate an existing Trino cluster record with a different name for that purpose.</li> </ul>"},{"location":"security/#formbasic-authentication","title":"Form/Basic authentication","text":"<p>The authentication happens with the pre-defined users from the configuration file. To define the preset user use the following section. Please note that 'privileges' can only be a combination of 'ADMIN', 'USER', and 'API', with '_' used for segmentation.</p> <pre><code>presetUsers:\n  user1:\n    password: &lt;password&gt;\n    privileges: ADMIN_USER\n  user2:\n    password: &lt;password&gt;\n    privileges: API\n</code></pre> <p>Also provide a random key pair in RSA format.</p> <pre><code>authentication:\n  defaultType: \"form\"\n  form:\n    selfSignKeyPair:\n      privateKeyRsa: &lt;private_key_path&gt;\n      publicKeyRsa: &lt;public_key_path&gt;\n</code></pre>"},{"location":"security/#formldap","title":"Form/LDAP","text":"<p>LDAP requires both random key pair and config path for LDAP</p> <pre><code>authentication:\n  defaultType: \"form\"\n  form:\n    ldapConfigPath: &lt;ldap_config_path&gt;\n    selfSignKeyPair:\n      privateKeyRsa: &lt;private_key_path&gt;\n      publicKeyRsa: &lt;public_key_path&gt;\n</code></pre>"},{"location":"security/#authorization","title":"Authorization","text":"<p>Trino Gateway supports the following roles in regex string format:</p> <ul> <li> <p>admin : Allows access to the Editor tab, which can be used to configure the   clusters</p> </li> <li> <p>user : Allows access to the rest of the website</p> </li> <li> <p>api : Allows access to rest apis to configure the clusters</p> </li> </ul> <p>Users with attributes next to the role will be giving those privileges the users. You can use the preset users defined in the yaml file.  LDAP Authorization is also supported by adding user attribute configs in file. An OAuth claim can be used by setting the <code>privilegesField</code> in the OAuth configuration.</p> <ul> <li>Check out LDAPTestConfig.yml file for config details</li> </ul> <pre><code># Roles should be in regex format\nauthorization:\n  admin: (.*)ADMIN(.*)\n  user: (.*)USER(.*)\n  api: (.*)API(.*)\n  ldapConfigPath: '&lt;ldap_config_path&gt;'\n</code></pre> <p>The LDAP config file should have the following contents:</p> <pre><code>  ldapHost: '&lt;ldap sever&gt;'\n  ldapPort: &lt;port&gt;\n  useTls: &lt;true/false&gt;\n  useSsl: &lt;true/false&gt;\n  ldapAdminBindDn: &lt;&gt;\n  ldapUserBaseDn: &lt;&gt;\n  ldapUserSearch: &lt;&gt;\n  ldapGroupMemberAttribute: &lt;&gt;\n  ldapAdminPassword: &lt;&gt;\n  ldapTrustStorePath: &lt;for a secure ldap connectivity&gt;\n  ldapTrustStorePassword: '&lt;for a secure ldap connectivity&gt;'\n  poolMaxIdle: 8\n  poolMaxTotal: 8\n  poolMinIdle: 0\n  poolTestOnBorrow: true\n</code></pre>"},{"location":"security/#web-page-permissions","title":"Web page permissions","text":"<p>By default, all pages are accessible to all roles. To limit page access, you can set page permissions by pages  and <code>_</code> as separator field.</p> <p>The following pages are available:</p> <ul> <li><code>dashboard</code></li> <li><code>cluster</code></li> <li><code>resource-group</code></li> <li><code>selector</code></li> <li><code>history</code></li> </ul> <pre><code># admin/api can access all pages, while user can only access dashboard/history\npagePermissions:\n  admin: \n  user: dashboard_history \n  api: \n</code></pre>"},{"location":"security/#extra-self-signed-certificate-in-trino-gateway","title":"Extra: Self-signed certificate in Trino Gateway","text":"<p>If Trino Gateway is using a self-signed certificate, client should use the <code>--insecure</code> config.</p> <pre><code>java -jar trino-cli-executable.jar --server https://localhost:8443 --insecure\n</code></pre>"},{"location":"security/#extra-self-signed-certificate-in-trino","title":"Extra: Self-signed certificate in Trino","text":"<p>If Trino is using a self-signed certificate, the following JVM config for Trino Gateway should be added:</p> <pre><code>-Djavax.net.ssl.trustStore=&lt;truststore file&gt;\n-Djavax.net.ssl.trustStorePassword=&lt;truststore password&gt;\n</code></pre> <p>If you want to skip the hostname validation for a self-signed certificate,  the <code>serverConfig</code> configuration should contain the following:</p> <pre><code>serverConfig:\n  proxy.http-client.https.hostname-verification: false\n  monitor.http-client.https.hostname-verification: false\n</code></pre>"},{"location":"users/","title":"Overview","text":"<p>The following organizations are known to use Trino Gateway and specific sections provide more details and references. Additional public material is referenced in the resources section.</p> <p>Some organizations may have stopped usage or requested not to be listed, while  many others are also using Trino Gateway without the Trino Gateway team's knowledge. </p> <p>Send a pull request or contact the Trino Gateway maintainers for additions or changes to the user list.</p>"},{"location":"users/#bestsecret","title":"BestSecret","text":"<p>Trino Gateway contributor Isa Inalcik works with Trino Gateway in the data platform at BestSecret as mentioned in Trino Community Broadcast 60</p>"},{"location":"users/#bloomberg","title":"Bloomberg","text":"<p>Trino Gateway maintainer Vishal Jadhav and  contributor Erik Anderson initiated the project with others. Andy Su is also a contributor. A large part of the initial contribution of Trino Gateway originated from their improved fork of Presto Gateway and they are active maintainers, contributors, and users of the project.</p>"},{"location":"users/#expedia","title":"Expedia","text":"<p>Trino Gateway contributor Prakhar Sapre is involved in the Trino Gateway usage at Expedia.</p>"},{"location":"users/#interco","title":"Inter&amp;Co","text":"<p>Trino Gateway user Yuri Niitsuma was instrumental in implementing Trino Gateway at Inter&amp;Co. At Inter&amp;Co, Trino Gateway is leveraged to route different user profiles and applications to distinct Trino clusters optimized for specific workloads. This separates low-latency and analytical queries, ensuring optimal performance for varying query requirements. Furthermore, Trino Gateway is used to perform seamless updates without any downtime, enhancing the reliability of the platform. It also facilitates the creation and management of a canary cluster, enabling the evaluation of different Trino configurations and upgrades in a controlled environment.</p>"},{"location":"users/#ly","title":"LY","text":"<p>Trino Gateway maintainer Star Poon is an active maintainer and contributor of major features and improvements, and leads the Trino Gateway usage at LY.</p>"},{"location":"users/#lyft","title":"Lyft","text":"<p>Lyft created to original, legacy Presto Gateway that led to Trino Gateway and  mentioned their usage of Presto Gateway in their engineering blog.</p>"},{"location":"users/#naver","title":"Naver","text":"<p>Trino Gateway maintainer Jaeho Yoo is an active maintainer and contributor of major features and improvements, and leads  the Trino Gateway usage at Naver.</p>"},{"location":"users/#pinterest","title":"Pinterest","text":"<p>Pinterest mentioned their usage of Presto Gateway in their engineering blog</p>"},{"location":"users/#shopify","title":"Shopify","text":"<p>Shopify mentioned their usage of Presto Gateway in their engineering blog.</p>"},{"location":"users/#slack","title":"Slack","text":"<p>Slack mentioned their usage of Trino Gateway in a presentation at the  datanova conference.</p>"},{"location":"users/#starburst","title":"Starburst","text":"<p>Trino Gateway maintainers Manfred Moser and Will Morrison initiated the project with others and are active maintainers and contributors to many aspects of the project. Yuya Ebihara and  Mateusz Gajewski are also a contributors.</p>"},{"location":"users/#zomato","title":"Zomato","text":"<p>Zomato mentioned their usage of Presto Gateway in their engineering blog.</p>"}]}